\section{\coq Mechanization}
\label{sec:coq}

Our \coq mechanization 
proves both type safety and
denotation soundness, \ie all the statements of~\S~\ref{sec:soundness}
and serves as a comparison for the metatheoretical 
development abilities of the two theorem provers. 
%is a translation from \lh
%and was built to compare the two developments. 
%
%All theorems from~\S~\ref{sec:soundness} are proven in \coq. %(\ie the proof has no \ha{Admitted}.)% and zero trusted code base. 
%
In \coq, 
Req. \ref{lem:prim-typing} 
is proved (using \coq's interactive development)
and type denotations (of \Cref{fig:den})
are defined as recursive functions using 
Equations~\cite{10.1145/3341690}, 
which make both the 
definition the denotational implementation
of the implication (\S~\ref{sec:typing:implication:denotational})
and the proof  
the denotational soundness (\Cref{lem:denote-sound-first})
possible. 
\begin{fullversion}
    The implication judgment
    is  axiomatized per Requirement \ref{lem:implication}.
\end{fullversion}
%
To fairly compare the two developments
%In order to better understand the relative strengths 
%and tradeoffs of \lh vs. \coq 
in terms of effort and ergonomics,
we did not use external \coq libraries 
%and implemented our own infrastructure 
because no such libraries exist yet for \lh.
%
\citet{Vazou17} previously compared \lh and \coq 
as theorem provers, but their mechanizations were an order of magnitude
smaller than ours and did not use data propositions (\S~\ref{sec:data-props}),
which permit constructive \lh proofs. 


\chapter{$\sysf$ Soundness}
\label{ch:systemF}

Next, we present the metatheory  
of the underlying (unrefined) 
$\sysf$. Even though it follows the textbook techniques of~\citet{TAPL},
it is a convenient 
stepping stone \emph{towards} 
the metatheory for (refined) $\sysrf$.
%
In addition, the soundness results 
for $\sysf$ are used \emph{for}                       %% TODO: point to specific
our full metatheory, as our well-formedness           %% places where sysf Soundness
judgments require the refinement                      %% used in Denot Sound metath.
predicate to have the $\sysf$ type 
$\tbool$ thereby avoiding the circularity 
of using a regular typing judgment in the 
antecedents of the well-formedness rules. 
%
% \mypara{Outline}
%
The \colboth boxes in Figure~\ref{fig:graph}
show the high level outline of the metatheory 
for $\sysf$ which provides a miniaturized model
for $\sysrf$ but without the challenges 
of subtyping
and existentials. Next, we describe the top-level 
type safety result, how it is decomposed into 
progress (Lemma~\ref{lem:progressFF}) and 
preservation (Lemma~\ref{lem:preservationFF}) 
lemmas, and the various technical results that 
support the lemmas.

Because the syntax of \sysf is identical to the
syntax of \sysrf, we have the slight complication
that refinements still appear in our terms.
%
Therefore in this chapter we continue to use $t, t', \ldots$ 
in our definitions and theorems to denote the 
refined types of \sysrf that will be used
in type annotations $\tyann{e}{t}$
and type applications $\tyapp{e}{t}$. 
%
To avoid confusion in the development of the
unrefined metatheory, we will
use $\sftype, \sftype',\ldots$ for 
\sysf types. 

\section{Static Semantics}
\label{sec:staticF}

The small-step semantics for \sysf are identical to
those of \sysrf (because the syntax is unchanged),
but the well-formedness and typing rules consist 
of those in Figures \ref{fig:wf} and \ref{fig:t}
with the parts in grey erased.
%
For clarity, 
and to make this chapter self-contained,
we present the $\sysf$ rules for
well-formedness in Figure \ref{fig:wff} and the 
rules for typing in Figure \ref{fig:ft}.

\begin{figure}%[t!]
  %
  %{\small
  \begin{mathpar}
  \judgementHead{Well-formed (Unrefined) Types}{\isWFFT{\tcenv}{\sftype}{\skind}}
  
  %%%%%%%%%%%% WELL-FORMEDNESS %%%%%%%%%%%%%
  %
  \inferrule% *[Right=\wtBase]
      {\sbase \in \{\tbool, \tint\}}
      {\isWFFT{\tcenv}{\sbase}{\skbase}}
      {\wfftBasic}
  \quad
  \inferrule% *[Right=]
      {\bind{\al}{\skind} \in \tcenv}
      {\isWFFT{\tcenv}{\al}{\skind}}
      {\wfftVar} 
  \quad
  \inferrule% *[Right=]
      { \isWFFT{\tcenv}{\sftype}{\skbase} }
      { \isWFFT{\tcenv}{\sftype}{\skstar} }
      {\wfftKind} 
  
  %    
  \inferrule% *[Right=\wtFunc]
      { \isWFFT{\tcenv}{\sftype_x}{\skind_x} \\\\
      \isWFFT{\tcenv}{\sftype}{\skind}
      }
      { \isWFFT{\tcenv}{\funcftype{\sftype_x}{\sftype}}{\skstar} }
      {\wfftFunc} 
  \quad
  \inferrule% *[Right=]
      { \forall\notmem{\al'}{\tcenv}. \;\;
        \isWFFT{\bind{\al'}{k}, \tcenv}{\subst{\sftype}{\al}{\al'}}{\skind_\sftype}
      }
      { \isWFFT{\tcenv}{\polytype{\al}{\skind}{\sftype}}{\skstar} }
      {\wfftPoly}
  %
  \end{mathpar}
  %}
  
  \vspace{-0.00cm}
  \caption{Well-formedness of $\sysf$ types.}
  \label{fig:wff}
  \label{fig:wfft}
  \vspace{-0.00cm}
\end{figure}



\begin{figure}
  %  {\small
    \begin{mathpar}             %%%%%%%%%%%%% TYPING %%%%%%%%%%%%%%%%%%
    \judgementHead{Typing}{\hasftype{\tcenv}{\sexpr}{\sftype}} \\
          \inferrule% *[Right=\tPrim]
          { % \ty{\sconst} = \stype
          }{\hasftype{\tcenv}{\sconst}{\forgetreft{\ty{\sconst}}}}
          {\fPrim}
      \quad
          \inferrule% *[Right=\tVar]
          {\bind{x}{\sftype} \in \tcenv  \\\\
            \isWFFT{\tcenv}{\sftype}{\skind}}
          {\hasftype{\tcenv}{x}{\sftype}}
          {\fVar}
      \quad
      \inferrule%*[Right=\tAnn]
      {\hasftype{\tcenv}{\sexpr}{\forgetreft{\stype}} \\\\
        \isWFFT{\tcenv}{{\forgetreft{\stype}}}{\skind}}
      {\hasftype{\tcenv}{\tyann{\sexpr}{\stype}}{{\forgetreft{\stype}}}}
      {\fAnn}
          \\
      %
      \inferrule% *[Right=\tApp]
      {
        \hasftype{\tcenv}{\sexpr_x}{\sftype_x}\\\\
        \hasftype{\tcenv}{\sexpr}{\funcftype{\sftype_x}{\sftype}}
      }
      {\hasftype{\tcenv}{\app{\sexpr}{\sexpr_x}}{\sftype}}
      {\fApp} 
      \quad
      \inferrule%*[Right=\tAbs]
          { \isWFFT{\tcenv}{\sftype_x}{\skind_x}\\\\
            \forall\notmem{y}{\tcenv}.
            \hastype{\bind{y}{\sftype_x},\tcenv}{\subst{\sexpr}{x}{y}}{\sftype} 
            }
          {\hastype{\tcenv}{\vabs{x}{\sexpr}}{\funcftype{\sftype_x}{\sftype}}}
          {\fAbs}
      %
      \quad
      %
      \inferrule% *[Right=\tTApp]
      {
        \isWFFT{\tcenv}{\forgetreft{\stype}}{\skind}\\\\
        \hastype{\tcenv}{\sexpr}{\polytype{\al}{\skind}{\sftype'}}
      }
      {\hastype{\tcenv}{\tyapp{\sexpr}{\stype}}
          {\subst{\sftype'}{\al}{\forgetreft{\stype}}}}
      {\fTApp}
      %
      \and
      %
          \inferrule% *[Right=\tTAbs]
          {\forall\notmem{\al'}{\tcenv}.\\\\
          \hastype{\bind{\al'}{\skind},\tcenv}{\subst{\sexpr}{\al}{\al'}}{\subst{\sftype}{\al}{\al'}}
          }
          {\hastype{\tcenv}{\tabs{\al}{\skind}{\sexpr}}{\polytype{\al}{\skind}{\sftype}}}
          {\fTAbs}
      \\    
      %
          \inferrule% *[Right=\tLet]
          {\hastype{\tcenv}{\sexpr_x}{\sftype_x} \\\\
          \forall\notmem{y}{\tcenv}.
          \hastype{\bind{y}{\sftype_x},\tcenv}{\subst{\sexpr}{x}{y}}
                {\sftype}
            }
          {\hastype{\tcenv}{\eletin{x}{\sexpr_x}{\sexpr}}{\sftype}}
          {\fLet}
      \quad  
      %
          \inferrule% *[Right=\tIf]
          {\hastype{\tcenv}{\sexpr}{\tbool} \\
          \hastype{\tcenv}{\sexpr_1}{\sftype}\\
          \hastype{\tcenv}{\sexpr_2}{\sftype}
            }
          {\hastype{\tcenv}{\eif{\sexpr}{\sexpr_1}{\sexpr_2}}{\sftype}}
          {\fIf}        
      \end{mathpar}
  %  }
  \vspace{-0.00cm}
  \caption{Unrefined typing rules.}
  \label{fig:ft}
  \label{fig:ftyping}
  \vspace{-0.00cm}
\end{figure}
    
\section{Metatheory for \sysf}
\label{sec:soundnessF}

% The proof of both of these theorems 
% is given by structural induction on 
% the typing judgment for the closed term. 
% %
% % The typing rules are syntax directed 
% % for $\sysf$, so we can uniquely determine 
% % the top level syntactic structure of our 
% % closed term.  
% % %
% We refer to this notion as Inversion of Typing.
% All of the theorems and lemmas mentioned here 
% appear in \colboth in Figure \ref{fig:graph}.
%
% \mypara{Type Safety}
%
The main type safety theorem for 
\sysf states that a well-typed 
term does not get stuck: \ie either 
evaluates to a value or can step 
to another term (progress) 
of the same type (preservation).
%
The judgment \hasftype{\tcenv}{\sexpr}{\sftype} 
is defined in~\cref{fig:ftyping}, and for clarity we use $\sftype$ 
for \sysf types and $\stype$ for the $\sysrf$ types that appear
in user annotations and in type applications. 

\begin{theorem} (Type Safety of \sysf) 
  \label{lem:soundnessF} %(\cref{app:lem:soundnessF} in App. \ref{ch:proofsF})
  \begin{enumerate}
      \item (Type Safety)
      If $\hastype{\varnothing}{\sexpr}{\sftype}$ and $\evalsTo{\sexpr}{\sexpr'}$,
      then $\sexpr'$ is a value or $\sexpr' \step \sexpr''$
      %and $\hastype{\varnothing}{\sexpr''}{\stype}$
      for some $\sexpr''$.
      \item (No Error)
      If $\hastype{\varnothing}{\sexpr}{\sftype}$ and $\evalsTo{\sexpr}{\sexpr'}$,
      then $\sexpr' \not = \eerr$.
  \end{enumerate}
  \end{theorem}
  %%
\begin{proof}
  (1) 
  We proceed by induction on the number of steps in 
  $\evalsTo{\sexpr}{\sexpr'}$.
  %
  There are two cases for $\evalsTo{\sexpr}{\sexpr'}$: 
  either $\sexpr=\sexpr'$ 
  or there exists a term $\sexpr_1$ 
  such that $\sexpr \step \evalsTo{\sexpr_1}{\sexpr'}$.
  %
  In the former case we conclude immediately 
  by the Progress Lemma (\ref{lem:progressFF} below).
  %
  In the latter case, $\hasftype{\varnothing}{\sexpr_1}{\sftype}$
  by the Preservation Lemma (\ref{lem:preservationFF}). 
  %
  Then by the inductive hypothesis
  applied to the reduction sequence $\evalsTo{\sexpr_1}{\sexpr'}$, 
  we conclude that either $\sexpr'$ is a value 
  or $\sexpr' \step \sexpr''$ for some $\sexpr''$ as desired. 

  (2) The second statement follows immediately from the first:
  we know that either $\sexpr'$ is a value and cannot be $\eerr$
  or $\sexpr'$ can take a step. But no rule in Figure \ref{fig:e}
  can be applied to reduce $\eerr$.
\end{proof}
%%
% %
As mentioned in the proof above,
we prove type safety by induction on the 
length of the sequence of steps comprising 
$\evalsTo{\sexpr}{\sexpr'}$, using the 
preservation and progress lemmas.

\subsection{Progress} \label{sec:sysf:progressF}
%
The progress lemma says a well-typed term is a value 
or steps to some other term.
%
\begin{lemma} (Progress) \label{lem:progressFF} 
If $\hasftype{\varnothing}{\sexpr}{\sftype}$, 
then $\sexpr$ is a value or $\sexpr \step \sexpr'$ for some $\sexpr'$.
\end{lemma}

\begin{proof} 
  We proceed by induction of the structure of 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$. In the cases of rule
  \fPrim, \fVar, \fAbs, or \fTAbs, $\sexpr$ is a value.
  \begin{itemize}
  %%
  \pfcase{\fApp}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \app{\sexpr_1}{\sexpr_2}$. 
  Inverting, we have that there exists some type $\sftype_2$
  such that $\hasftype{\varnothing}{\sexpr_1}{\funcftype{\sftype_2}{\sftype}}$
  and $\hasftype{\varnothing}{\sexpr_2}{\sftype_2}$.
  We split on five possible cases for 
  the structure of $\sexpr_1$ and $\sexpr_2$. 
  %
  First, suppose $\sexpr_1 \equiv \vabs{x}{\sexpr_0}$ and $\sexpr_2$ is 
  a value. Then by rule \eAppAbs, 
  $e \equiv \app{\vabs{x}{\sexpr_0}}{\sexpr_2} \step \subst{\sexpr_0}{x}{\sexpr_2}$.
  %
  Second, suppose $\sexpr_1 \equiv \vabs{x}{\sexpr_0}$ and $\sexpr_2$
  is not a value. Then by the inductive hypothesis, there exists a term
  $\sexpr'_2$ such that $\sexpr_2 \step \sexpr'_2$. Then by rule \eAppV
  $e \equiv \app{\vabs{x}{\sexpr_0}}{\sexpr_2} \step \app{\vabs{x}{\sexpr_0}}{\sexpr'_2}$.
  %
  Third, suppose $\sexpr_1 \equiv \sconst$, a built in primitive 
  and $\sexpr_2$ is a value. Then by rule \ePrim, 
  $e \equiv \app{\sconst}{\sexpr_2} \step \delta(\sconst,\sexpr_2)$,
  which is well-defined by the Primitives Lemma (\ref{lem:primitivesF}).
  %
  Fourth, suppose $\sexpr_1 \equiv \sconst$ and $\sexpr_2$
  is not a value. Then by the inductive hypothesis, there exists a term
  $\sexpr'_2$ such that $\sexpr_2 \step \sexpr'_2$. Then by rule \eAppV
  $e \equiv \app{\sconst}{\sexpr_2} \step \app{\sconst}{\sexpr'_2}$.
  %
  Finally, by the Canonical Forms Lemma (\ref{lem:canonicalF}),
  $\sexpr_1$ cannot be any other
  value, so it must not be a value. Then by the inductive hypothesis,
  there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$. 
  Then by rule \eApp,
  $e \equiv \app{\sexpr_1}{\sexpr_2} \step \app{\sexpr'_1}{\sexpr_2}$.
  %%
  \pfcase{\fTApp}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \tyapp{\sexpr_1}{\stype}$ and
  $\sftype \equiv \subst{\sigma}{\tvar}{\forgetreft{\stype}}$. 
  Inverting, we have that 
  $\hasftype{\varnothing}{\sexpr_1}{\polytype{\tvar}{\skind}{\sigma}}$.
  We split on three cases for the structure of $\sexpr_1$.
  %
  First, suppose $\sexpr_1 \equiv \tabs{\tvar'}{\skind'}{\sexpr_0}$.
  Then by rule \eTAppAbs, 
  $\sexpr \equiv \tyapp{\tabs{\tvar'}{\skind'}{\sexpr_0}}{\stype} 
  \step \subst{\sexpr_0}{\tvar'}{\stype}$.
  %
  Second, suppose $\sexpr_1 \equiv \sconst$, a built in primitive.
  Then by rule \eTPrim, 
  $\sexpr \equiv  \tyapp{\sconst}{\stype} \step \delta_T(\sconst,\forgetreft{\stype})$,
  which is well-defined by the Primitives Lemma (\ref{lem:primitivesF}).
  %
  Finally, by the Canonical Forms Lemma (\ref{canonicalF}), 
  $\sexpr_1$ cannot be any other
  form of value, so it must not be a value. 
  Then by the inductive hypothesis,
  there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$. 
  Then by rule \eTApp
  $\sexpr \equiv \tyapp{\sexpr_1}{\stype} \step \tyapp{\sexpr'_1}{\stype}$.
  %%
  \pfcase{\fLet}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \eletin{x}{\sexpr_1}{\sexpr_2}$. Inverting,
  we have that $\hasftype{\varnothing}{\sexpr_1}{\sftype_1}$
  for some type $\sftype_1$. 
  By the inductive hypothesis, either $\sexpr_1$ is a value
  or there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$.
  In the former case, rule \eLetV gives us
  $e \equiv \eletin{x}{\sexpr_1}{\sexpr_2} \step \subst{\sexpr_2}{x}{\sexpr_1}$.
  In the latter case, by rule \eLet, 
  $e \equiv \eletin{x}{\sexpr_1}{\sexpr_2} \step \eletin{x}{\sexpr'_1}{\sexpr_2}$.
  %%
  \pfcase{\fAnn}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \tyann{\sexpr_1}{\stype}$. Inverting,
  we have the $\hasftype{\varnothing}{\sexpr_1}{\sftype}$ and
  $\sftype = \forgetreft{\stype}$. 
  By the inductive hypothesis, either $\sexpr_1$ is a value
  or there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$.
  In the former case, by rule \eAnnV, 
  $e \equiv \tyann{\sexpr_1}{\stype} \step \sexpr_1$.
  In the latter case, rule \eAnn gives us 
  $e \equiv \tyann{\sexpr_1}{\stype} step \tyann{\sexpr'_1}{\stype}$.
   %%
   \pfcase{\fIf}: We have 
   $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
   $\sexpr \equiv \eif{\sexpr}{\sexpr_1}{\sexpr_2}$. Inverting,
   we have that $\hasftype{\varnothing}{\sexpr}{\tbool}$.
   By the inductive hypothesis, either $\sexpr$ is a value
   or there is a term $\sexpr'$ such that $\sexpr \step \sexpr'$.
   In the former case, by the Canonical Forms Lemma (\ref{lem:canonicalF}),
   we have that $\sexpr = \ttrue$ or $\sexpr = \tfalse$, and so
   either 
   $e \equiv \eif{\ttrue}{\sexpr_1}{\sexpr_2} \step \sexpr_1$
   by rule \eIfT or (respectively)
   $e \equiv \eif{\tfalse}{\sexpr_1}{\sexpr_2} \step \sexpr_2$
   by rule \eIfF.
   %
   In the latter case, by rule \eIf, 
   $e \equiv \eif{\sexpr}{\sexpr_1}{\sexpr_2} \step \eif{\sexpr'}{\sexpr_1}{\sexpr_2}$.
  %%
  \end{itemize}
  \end{proof}

\begin{fullversion}
%
The proof of progress given above requires a \emph{Canonical Forms} 
lemma (\cref{lem:canonicalF}) which describes the 
shape of well-typed values and some key properties 
about the built-in \emph{Primitives} (\cref{lem:primitivesF}).
%
We also implicitly use an \emph{Inversion of Typing} 
lemma (\cref{lem:inversionF}) which describes the shape of the 
type of well-typed terms and its subterms. For $\sysf$, 
unlike $\sysrf$, this lemma
is trivial because the typing relation is syntax-directed.


\begin{lemma}\label{lem:canonicalF} (Canonical Forms) 
\begin{enumerate}
    \item If $\hasftype{\varnothing}{v}{\tbool}$, 
        then $v = \ttrue$ or $v = \tfalse$.
    \item If $\hasftype{\varnothing}{v}{\tint}$, then $v$ is an integer constant.
    \item If $\hasftype{\varnothing}{v}{\funcftype{\sftype}{\sftype'}}$, 
        then either $v = \vabs{x}{\sexpr}$ or $v = \sconst$, 
        a constant function where 
        $\sconst \in \{\wedge, \vee, \neg, \leftrightarrow \}$.
    \item If $\hasftype{\varnothing}{v}{\polytype{\al}{\skind}{\sftype}}$, 
        then either $v = \tabs{\al}{\skind}{\sexpr}$ 
        or $v = \sconst$, a polymorphic constant $\sconst \in \{\leq, =\}$.
    \item If $\isWFFT{\varnothing}{\sftype}{\skbase}$,
        then $\sftype = \tbool$ or $\sftype = \tint$.
\end{enumerate}
\end{lemma}
%%
\begin{proof}
    Parts (1) - (4) are easily deduced from the \sysf typing rules 
    in Figure \ref{fig:t} and the definition of $ty(c)$. 
    Part (5) is clear from the well-formedness rules in Figure \ref{fig:wf}.
\end{proof}

We note that 
Lemma \ref{lem:canonicalF-a} is sufficient for our $\sysrf$ metatheory.
Our syntactic typing judgments in $\sysrf$ respect those of $\sysf$.
Specifically, if $\hastype{\tcenv}{\sexpr}{\stype}$ and 
$\isWellFormedE{\tcenv}$, then
$\hasftype{\forgetreft{\tcenv}}{\sexpr}{\forgetreft{\stype}}$.
Therefore, we do not have to state and 
prove a separate Canonical Forms Lemma for $\sysrf$.
%%

\begin{lemma}\label{lem:inversionF} (Inversion of Typing) 
    \begin{enumerate}% [leftmargin=*]
        \item If $\hasftype{\tcenv}{c}{\sftype}$, 
            then $\sftype = \forgetreft{\ty{c}}$.
        \item If $\hasftype{\tcenv}{x}{\sftype}$, 
            then $\bind{x}{\sftype} \in \tcenv$.
        \item If $\hasftype{\tcenv}{\app{e}{e_x}}{\sftype}$,
            then there exists type $\sftype_x$ such that  
            $\hasftype{\tcenv}{e}{\funcftype{\sftype_x}{\sftype}}$ and
            $\hasftype{\tcenv}{e_x}{\sftype_x}$.
        \item If $\hasftype{\tcenv}{\vabs{x}{e}}{\sftype}$,\! 
            then $\sftype = \funcftype{\sftype_x}{\sftype'}$ and
            $\hasftype{\bind{y}{\sftype_x},\tcenv}{\subst{e}{x}{y}}{\sftype'}$
            for any $\notmem{y}{\tcenv}$ and well-formed $\sftype_x$.
        \item If $\hasftype{\tcenv}{\tyapp{e}{t}}{\sftype}$,\! then there exists 
            type $\sigma$ and kind $\skind$ such that 
            $\hasftype{\tcenv}{e}{\polytype{\al}{\skind}{\sigma}}$
            and $\sftype = \subst{\sigma}{\al}{\forgetreft{t}}$.
        \item If $\hasftype{\tcenv}{\tabs{\al}{\skind}{e}}{\sftype}$, then
            there exists type $\sftype'$ and kind $\skind$ such that
            $\sftype = {\polytype{\al}{\skind}{\sftype'}}$ and
            $\hasftype{\bind{\al'}{\skind},\tcenv}{\subst{e}{\al}{\al'}}
            {\subst{\sftype'}{\al}{\al'}}$ for some $\notmem{\al'}{\tcenv}$.
        \item If $\hasftype{\tcenv}{\eletin{x}{e_x}{e}}{\sftype}$, then
            there exists type $\sftype_x$ and $\notmem{y}{\tcenv}$ such that
            $\hasftype{\tcenv}{e_x}{\sftype_x}$ and 
            $\hasftype{\bind{y}{\sftype_x},\tcenv}{\subst{e}{x}{y}}{\sftype}$.
        \item If $\hasftype{\tcenv}{\tyann{e}{t}}{\sftype}$, then 
            $\sftype = \forgetreft{t}$ and $\hasftype{\tcenv}{e}{\sftype}$.
        
        \item If $\hasftype{\tcenv}{\eif{e}{e_1}{e_2}}{\sftype}$, then
            $\hasftype{\tcenv}{e}{\tbool}$,
            $\hasftype{\tcenv}{e_1}{\sftype}$, and 
            $\hasftype{\tcenv}{e_2}{\sftype}$.
    \end{enumerate}
\end{lemma}
%%
\begin{proof}
This is clear from the definition of the typing rules for $\sysf$. Each premise
can match only one rule because the $\sysf$ rules are syntax directed.
\end{proof}
%%
The Inversion of Typing Lemma does not hold in $\sysrf$ due to the subtyping
relation. For instance 
$\hastype{\bind{x}{\breft{\tint}{\vv}{\vv = 5}}}{x}{\tint}$ but
$\notmem{\bind{x}{\tint}}{\bind{x}{\breft{\tint}{\vv}{\vv = 5}}}$.
In Lemma \ref{lem:inversion} we state and prove an analogous result 
for $\sysrf$ in the two cases needed to prove progress and preservation.
%% % TODO ^^^ recheck that this lemma is still there!

%\mypara{Primitives}
%
For each primitive constant or function, we need 
to know that the type $\forgetreft{\ty{\sconst}}$ 
relates to the $\sysf$ type of $\delta(\sconst,v)$ 
in the same manner as \fApp.
%
% While we could derive this from (\ref{prim-typing}), 
% it is straightforward enough to prove from scratch 
% in the mechanization.

\begin{lemma}\label{lem:primitivesF}(Primitives) 
For each built-in primitive $c$, 
%
\begin{enumerate} 
\item If $\forgetreft{\ty{\sconst}} = \funcftype{\sftype_x}{\sftype}$
    and $\hasftype{\varnothing}{v_x}{\sftype_x}$, 
    then % $\delta(\sconst,v)$ is defined and 
    $\hasftype{\varnothing}{\delta(\sconst,v_x)}{\sftype}$.
\item If $\forgetreft{\ty{\sconst}} = \polytype{\al}{\skind}{\sftype}$ 
    and $\isWellFormed{\varnothing}{\sftype_\al}{\skind}$, 
    then % $\delta_T(\sconst,\stype)$ is defined and we have 
    $\hasftype{\varnothing}{\delta_T(\sconst,\sftype_\al)}{\subst{\sftype}{\al}{\sftype_\al}}$.
    \end{enumerate}
\end{lemma}
%%
\begin{proof}
  \begin{enumerate}
      \item First consider $\sconst \in \{\wedge, \vee, \neg\}$. 
          Then $\forgetreft{\ty{\sconst}} = \funcftype{\tbool}{\funcftype{\tbool}{\tbool}}$.
          Then by Lemma \ref{lem:canonicalF}, $\hasftype{\varnothing}{\sval}{\tbool}$
          gives us that $\sval = \ttrue$ or $\sval = \tfalse$.
          For each possibility for $\sconst$ and $\sval$, we can build a judgment 
          that $\hasftype{\varnothing}{\delta(\sconst,\sval)}{\funcftype{\tbool}{\tbool}}$.
          Similarly, if $\sconst = \neg$ 
          then $\forgetreft{\ty{\sconst}} = \funcftype{\tbool}{\tbool}$ and 
          $\delta(\neg,\sval) \in \{\ttrue,\tfalse\}$ can be typed at $\tbool$.
          The analysis for the other monomorphic primitives is entirely similar.
      \item Here $\sconst$ is the polymorphic $=$ and 
          $\forgetreft{\ty{\sconst}} = \polytype{\tvar}{\skbase}{\funcftype{\al}{\funcftype{\al}{\tbool}}}$. By the Canonical Forms Lemma, 
          $\sftype = \tbool$ or $\sftype = \tint$. In the former case,
          $\delta_T(\sconst,\tbool) = \leftrightarrow$, which we can type at 
          $\funcftype{\tbool}{\funcftype{\tbool}{\tbool}} =\subst{\forgetreft{\ty{\sconst}}}{\tvar}{\tbool}$. The case of $\tint$ is entirely similar
          because $\delta_T(\sconst,\tint)$ is the monomorphic integer equality.
  \end{enumerate}
  \end{proof}

%\NV{Michael check the below}
%Lemmas~\ref{lem:canonicalF} and~\ref{lem:inversionF} are proved without
%induction by inspection of the derivation tree, 
%while lemma~\ref{lem:primitivesF} relies on 
%the Primitives Requirement~\ref{lem:prim-typing}. 

\end{fullversion}

\subsection{Preservation} \label{sec:sysf:preservationF}
%
The preservation lemma states that $\sysf$ typing is preserved
by evaluation.
%
\begin{lemma} (Preservation) \label{lem:preservationFF} 
If $\hasftype{\varnothing}{\sexpr}{\sftype}$ and $\sexpr \step \sexpr'$, 
then $\hasftype{\varnothing}{\sexpr'}{\sftype}$.
\end{lemma}    
%%
\begin{proof} 
  We proceed by induction of the structure of 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$. The cases of rules
  \fPrim, \fVar, \fAbs, or \fTAbs cannot occur because $\sexpr$ is a value
  and no value can take a step in our semantics.
  %%
  The interesting cases are for \fApp and \fTApp.
  %
  For applications of primitives, preservation 
  requires the Primitives~\Cref{lem:primitivesF},
  while the general case needs a Substitution~\Cref{lem:substitutionF}.
  %
  We now give the full details of the other five cases:

  \begin{itemize}
  %%
  \pfcase{\fApp}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \app{\sexpr_1}{\sexpr_2}$. 
  Inverting, we have that there exists some type $\sftype_2$
  such that $\hasftype{\varnothing}{\sexpr_1}{\funcftype{\sftype_2}{\sftype}}$
  and $\hasftype{\varnothing}{\sexpr_2}{\sftype_2}$.
  We split on five possible cases for 
  the structure of $\sexpr_1$ and $\sexpr_2$. 
  %
  First, suppose $\sexpr_1 \equiv \vabs{x}{\sexpr_0}$ and $\sexpr_2$ is 
  a value. Then by rule \eAppAbs and the determinism of our semantics, 
  $e' \equiv \subst{\sexpr_0}{x}{\sexpr_2}$.
  By the Inversion of Typing (\ref{lem:inversionF}), for some $y$ we have
  $\hasftype{\bind{y}{\sftype_2}}{\subst{\sexpr_0}{x}{y}}{\sftype}$.
  By the Substitution Lemma (\ref{lem:substitutionFF}), 
  substituting $\sexpr_2$ through for $y$
  gives us $\hasftype{\varnothing}{\subst{\sexpr_0}{x}{\sexpr_2}}{\sftype}$
  as desired because $\subst{\subst{\sexpr_0}{x}{y}}{y}{\sexpr_2} = \subst{\sexpr_0}{x}{\sexpr_2}$.
  %
  Second, suppose $\sexpr_1 \equiv \vabs{x}{\sexpr_0}$ and $\sexpr_2$
  is not a value. Then by the progress lemma (\ref{lem:progressFF}), 
  there exists a term
  $\sexpr'_2$ such that $\sexpr_2 \step \sexpr'_2$. Then by rule \eAppV
  and the determinism of our semantics,
  $e' \equiv \app{\vabs{x}{\sexpr_0}}{\sexpr'_2}$. 
  Now, by the inductive hypothesis, 
  $\hasftype{\varnothing}{\sexpr'_2}{\sftype_2}$.
  Applying rule \fApp, 
  $\hasftype{\varnothing}{\app{\sexpr_1}{\sexpr'_2}}{\sftype}$
  as desired.
  %
  Third, suppose $\sexpr_1 \equiv \sconst$, a built in primitive, 
  and $\sexpr_2$ is a value. Then by rule \ePrim
  and the determinism of the semantics, 
  $e' \equiv \delta(\sconst,\sexpr_2)$.
  By the primitives lemma, 
  $\hasftype{\varnothing}{\delta(\sconst,\sexpr_2)}{\sftype}$ as desired.
  %
  Fourth, suppose $\sexpr_1 \equiv \sconst$ and $\sexpr_2$
  is not a value. Then we argue in the same manner as the second case.
  %
  Finally, by the canonical forms lemma, $\sexpr_1$ cannot be any other
  value, so it must not be a value. Then by the progress lemma,
  there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$. 
  Then by rule \eApp and the determinism of the semantics,
  $e' \equiv \app{\sexpr'_1}{\sexpr_2}$. By the inductive hypothesis,
  $\hasftype{\varnothing}{\sexpr'_1}{\funcftype{\sftype_2}{\sftype}}$.
  Applying rule \fApp, $\hasftype{\varnothing}{\app{\sexpr'_1}{\sexpr_2}}{\sftype}$
  as desired.
  %%
  \pfcase{\fTApp}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \tyapp{\sexpr_1}{\stype}$ and
  $\sftype \equiv \subst{\sigma}{\tvar}{\forgetreft{\stype}}$. 
  Inverting (\ref{lem:inversionF}), we have that 
  $\hasftype{\varnothing}{\sexpr_1}{\polytype{\tvar}{\skind}{\sigma}}$
  and $\isWFFT{\varnothing}{\forgetreft{\stype}}{\skind}$.
  We split on three cases for the structure of $\sexpr_1$.
  %
  First, suppose $\sexpr_1 \equiv \tabs{\tvar}{\skind}{\sexpr_0}$.
  Then by rule \eTAppAbs and the determinism of the semantics, 
  $\sexpr' \equiv \subst{\sexpr_0}{\tvar}{\stype}$.
  By the inversion of typing, for some $\tvar'$, we have
  $\hasftype{\bind{\tvar'}{\skind}}{\subst{\sexpr_0}{\tvar}{\tvar'}}
  {\subst{\sigma}{\tvar}{\tvar'}}$.
  By the Substitution Lemma (\ref{lem:substitutionFF}), 
  substituting $\forgetreft{\stype}$ 
  through for $\tvar$  gives us 
  $\hasftype{\varnothing}{\subst{\sexpr_0}{\tvar}{\stype}}{\subst{\sigma}{\tvar}{\forgetreft{\stype}}}$ as desired.
  %
  Second, suppose $\sexpr_1 \equiv \sconst$, a built in primitive.
  Then by rule \eTPrim and the determinism of the semantics, 
  $\sexpr' \delta_T(\sconst,\forgetreft{\stype})$. By the primitives lemma,
  $\hasftype{\varnothing}{\delta_T(\sconst,\forgetreft{\stype})}{\subst{\sigma}{\tvar}{\forgetreft{\stype}}}$.
  %
  Finally, by the canonical forms lemma, $\sexpr_1$ cannot be any other
  form of value, so it must not be a value. Then by the progress lemma,
  there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$. 
  Then by rule \eTApp and the deterministic semantics
  $\sexpr' \equiv \tyapp{\sexpr'_1}{\stype}$.  By the inductive hypothesis,
  $\hasftype{\varnothing}{\sexpr'_1}{\polytype{\tvar}{\skind}{\sigma}}$.
  Applying rule \fTApp, 
  $\hasftype{\varnothing}{\tyapp{\sexpr'_1}{\stype}}{\subst{\sigma}{\tvar}{\forgetreft{\stype}}}$
  as desired.
  %%
  \pfcase{\fLet}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \eletin{x}{\sexpr_1}{\sexpr_2}$. Inverting,
  we have that 
  $\hasftype{\bind{y}{\sftype_1}}{\subst{\sexpr_2}{x}{y}}{\sftype}$
  and $\hasftype{\varnothing}{\sexpr_1}{\sftype_1}$
  for some type $\sftype_1$. 
  By the progress lemma either $\sexpr_1$ is a value
  or there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$.
  %
  In the former case, rule \eLetV and determinism give us
  $\sexpr' \equiv \subst{\sexpr_2}{x}{\sexpr_1}$.
  By the Substitution Lemma (substituting $\sexpr_1$ for $x$), 
  we have $\hasftype{\varnothing}{\subst{\sexpr_2}{x}{\sexpr_1}}{\sftype}$
  as desired because 
  $\subst{\sexpr_2}{x}{\sexpr_1} = \subst{\subst{\sexpr_2}{x}{y}}{y}{\sexpr_1}$.
  %
  In the latter case, by rule \eLet and determinism give us, 
  $\sexpr' \equiv \eletin{x}{\sexpr'_1}{\sexpr_2}$.
  By the inductive hypothesis we have that 
  $\hasftype{\varnothing}{\sexpr'_1}{\sftype_1}$ and by rule \fLet 
  we have $\hasftype{\varnothing}{\eletin{x}{\sexpr'_1}{\sexpr_2}}{\sftype}$. 
  %%
  \pfcase{\fAnn}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \tyann{\sexpr_1}{\stype}$. Inverting,
  we have the $\hasftype{\varnothing}{\sexpr_1}{\sftype}$ and
  $\sftype = \forgetreft{\stype}$. 
  By the progress lemma, either $\sexpr_1$ is a value
  or there is a term $\sexpr'_1$ such that $\sexpr_1 \step \sexpr'_1$.
  %
  In the former case, by rule \eAnnV and the determinism of the semantics, 
  $\sexpr' \equiv \sexpr_1$. Then we already have that
  $\hasftype{\varnothing}{\sexpr'}{\sftype}$
  %
  In the latter case, rule \eAnn and determinism give us 
  $\sexpr' \equiv \tyann{\sexpr'_1}{\stype}$. By the inductive hypothesis
  we have that $\hasftype{\varnothing}{\sexpr'_1}{\sftype}$. By rule
  \fAnn we conclude $\hasftype{\varnothing}{\tyann{\sexpr'_1}{\stype}}{\sftype}$.
  %%
  \pfcase{\fIf}: We have 
  $\hasftype{\varnothing}{\sexpr}{\sftype}$ where
  $\sexpr \equiv \eif{\sexpr_0}{\sexpr_1}{\sexpr_2}$. Inverting,
  we have that 
  $\hasftype{\varnothing}{\sexpr_0}{\tbool}$
  and
  $\hasftype{\varnothing}{\sexpr_1}{\sftype}$,
  and
  $\hasftype{\varnothing}{\sexpr_2}{\sftype}$.
  %
  By the progress lemma either $\sexpr_0$ is a value
  or there is a term $\sexpr'_0$ such that $\sexpr_0 \step \sexpr'_0$.
  %
  In the former case, the Canonical Forms Lemma (\ref{lem:canonicalF})
  tells us that $\sexpr_0 = \ttrue$ or $\tfalse$.
  By determinism of the semantics we have that 
  $\sexpr' \equiv {\sexpr_1}$
  or $\sexpr' \equiv {\sexpr_2}$ respectively.
  %
  In either case we can immediately conclude that $\sexpr'$
  has the desired type.
  %
  In the latter case above,rule \eIf and determinism give us, 
  $\sexpr' \equiv \eif{\sexpr'_0}{\sexpr'_1}{\sexpr_2}$.
  By the inductive hypothesis we have that 
  $\hasftype{\varnothing}{\sexpr'_0}{\tbool}$ and by rule \fIf 
  we have 
  $\hasftype{\varnothing}{\eif{\sexpr'_0}{\sexpr_1}{\sexpr_2}}{\sftype}$. 
  %%
  \end{itemize}
\end{proof}
%
The proof of preservation for $\sysrf$ differs in two cases above. 
In \tApp and \tTApp, we must use the 
Inversion of Typing lemma (\ref{lem:inversion})
from $\sysrf$ because the presence of rule \tSub prevents us from 
inferring the last rule used to type a term or type abstraction.
%
Furthermore, in case \tApp the substitution lemma would give us that 
$\hastype{\varnothing}{\sexpr'}{\subst{\stype}{x}{\sval_x}}$ for 
some value $\sval_x$. However we need to show preservation of the
existential type $\existype{x}{\stype_x}{\stype}$. This is done by
using rule \sWitn to show that, in fact, 
$\isSubType{\varnothing}{\subst{\stype}{x}{\sval_x}}{\existype{x}{\stype_x}{\stype}}$.
%%

\mypara{Substitution Lemma}
%
To prove type preservation when
a lambda or type abstraction is applied, 
we proved that the substituted result 
has the same type, as established by 
the Substitution Lemma:
%
\begin{lemma}(Substitution)\label{lem:substitutionFF}
If $\hasftype{\tcenv}{\sval_x}{\sftype_x}$ 
and $\isWFFT{\tcenv}{\forgetreft{\stype_{\al}}}{k_{\al}}$, then 
\begin{enumerate}
\item if\; $\hasftype{\tcenv', \bind{x}{\sftype_x}, \tcenv}{\sexpr}{\sftype}$
    and\; $\isWFFE{\tcenv}$, then
    ${\hasftype{\tcenv', \tcenv}{\subst{\sexpr}{x}{\sval_x}}{\sftype}}$ and 
\item if\; $\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sexpr}{\sftype}$
    and\; $\isWFFE{\tcenv}$, then
    ${\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
               {\subst{\sexpr}{\al}{\stype_{\al}}}
               {\subst{\sftype}{\al}{\forgetreft{\stype_{\al}}}}}$.
\end{enumerate}
\end{lemma}
%%
\begin{proof}
  We give the proofs for part (2); part (1) is similar but slightly
  simpler because term variables do not appear in types in $\sysf$
  We proceed by induction on the derivation tree of the typing judgment
  $\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sexpr}{\sftype}$.
  %%
  \pfcase{\fPrim}: We have $\sexpr \equiv \sconst$ and
  $\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sconst}{\forgetreft{\ty{\sconst}}}$.
  Neither $\sconst$ nor $\ty{\sconst}$ has any free variables, so each is 
  unchanged under substitution. Then by rule \tPrim we conclude
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}{\sconst}{\forgetreft{\ty{\sconst}}}$ because the environment may be chosen arbitrarily.
  %%
  \pfcase{\fVar}: We have $\sexpr \equiv x$; by inversion, we get that 
  $\bind{x}{\sftype} \in \tcenv', \bind{\al}{k_{\al}}, \tcenv$. We must have
  $\tvar \neq x$ so there are two cases to consider for where $x$ can 
  appear in the environment. If $\bind{x}{\sftype} \in \tcenv$,  then $\sftype$
  cannot contain $\tvar$ as a free variable because $x$ is bound first in the environment (which grows from right to left). Then
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}{x}{\sftype}$
  as desired because $\subst{\sftype}{\tvar}{\forgetreft{\stype_{\al}}} = \sftype$.
  Otherwise $\bind{x}{\sftype} \in \tcenv'$ and so 
  $\bind{x}{\subst{\sftype}{\tvar}{\forgetreft{\stype_{\al}}}} \in \subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv$. Thus
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}{x}{\subst{\sftype}{\tvar}{\forgetreft{\stype_{\al}}}}$.
  %
  (In part (1), we have an additional case where 
  $\hasftype{\tcenv', \bind{x}{\sftype}, \tcenv}{x}{\sftype}$. We have
  $\subst{x}{x}{\sval_x} = \sval_x$ and so we can apply 
  the Weakening Lemma (\ref{lem:weakeningF})
  to $\hasftype{\tcenv}{\sval_x}{\sftype}$ to obtain
  $\hasftype{\tcenv', \tcenv}{\sval_x}{\sftype}$.)
  %%
  \pfcase{\fApp}: We have $\sexpr \equiv \app{\sexpr_1}{\sexpr_2}$. By inversion
  we have that
  $\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sexpr_1}{\funcftype{\sftype_x}{\sftype}}$
  and $\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sexpr_2}{\sftype_x}$.
  Applying the inductive hypothesis to both of these, we get
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}{\subst{\sexpr_1}{\tvar}{\stype_{\tvar}}}{\subst{\funcftype{\sftype_x}{\sftype}}{\tvar}{\forgetreft{\stype_{\tvar}}}}$
  and
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}{\subst{\sexpr_2}{\tvar}{\stype_{\tvar}}}{\subst{\sftype_x}{\tvar}{\forgetreft{\stype_{\tvar}}}}$. 
  Combining these by rule \fApp, we conclude
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}{\subst{\app{\sexpr_1}{\sexpr_2}}{\tvar}{\stype_{\tvar}}}{\subst{\sftype}{\tvar}{\forgetreft{\stype_{\tvar}}}}$.
  %%
  \pfcase{\fAbs}: We have $\sexpr \equiv \vabs{x}{\sexpr_1}$ 
  and $\sftype \equiv \funcftype{\sftype_x}{\sftype_1}$. 
  By inversion we have that for any fresh $y$, both
  $\hasftype{\bind{y}{\sftype_x},\tcenv', \bind{\al}{k_{\al}}, \tcenv}
  {\subst{\sexpr_1}{x}{y}}{\sftype_1}$
  and
  $\isWFFT{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sftype_x}{\skind_x}$.
  By the inductive hypothesis, and the Substitution Lemma for 
  well-formedness judgments, we have
  $\hasftype{\bind{y}{\subst{\sftype_x}{\al}{\forgetreft{\stype_{\al}}}},\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
  {\subst{\subst{\sexpr_1}{\al}{\stype_{\al}}}{x}{y}}{\subst{\sftype_1}{\al}{\forgetreft{\stype_{\al}}}}$
  and
  $\isWFFT{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
  {\subst{\sftype_x}{\al}{\forgetreft{\stype_{\al}}}}{\skind_x}$,
  where we can switch the order of substitutions because $y$ does not 
  appear free in the well-formed type $\stype_{\tvar}$.
  Then we can conclude by applying rule \fAbs that 
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
  {\subst{\vabs{x}{\sexpr_1}}{\tvar}{\stype_\tvar}}
  {\subst{\funcftype{\sftype_x}{\sftype_1}}{\tvar}{\forgetreft{\stype_\tvar}}}$.
  %%
  \pfcase{\fTApp}: We have $e \equiv e'\; [\stype']$ 
  and $\sftype \equiv \subst{\sftype'}{\al'}{\forgetreft{\stype'}}$. 
  By inversion, 
  $\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{e'}{\polytype{\al'}{k'}{\sftype'}}$
  and $\isWFFT{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\forgetreft{\stype'}}{k'}$.
  By the inductive hypothesis,\\
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
    {\subst{e'}{\al}{\stype_{\al}}}
    {\polytype{\al'}{k'}{\subst{\sftype'}{\al}{\forgetreft{\stype_{\al}}}}}$
  %\]
  and
  %\begin{equation}\label{362T}
  $\isWFFT{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
    {\subst{\forgetreft{\stype'}}{\al}{\forgetreft{\stype_{\al}}}}{k'}$.
  %\end{equation}
  By the definition of refinement erasure,
  $ \subst{\forgetreft{\stype}}{\al'}{\forgetreft{\stype_{\al}}} 
      = \forgetreft{\subst{\stype'}{\al}{\stype_{\al}}}$.
  By applying rule \fTApp, we get
  %\begin{equation}
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
    {\tyapp{\subst{e'}{\al}{\stype_{\al}}}{\subst{\stype'}{\al}{\stype_{\al}}}}
    {\subst{\subst{\sftype'}{\al}{\forgetreft{\stype_{\al}}}}
      {\al'}{\forgetreft{\subst{\stype'}{\al}{\stype_{\al}}}}}$.
  %
  By the definition of substitution we have 
  $\tyapp{\subst{e'}{\al}{\stype_{\al}}}{\subst{\stype'}{\al}{\stype_{\al}}} 
      = \subst{\tyapp{e'}{t'}}{\al}{\stype_{\al}}$
  and by the commutativity rules for substitution,\\
  $ \subst{\subst{\sftype'}{\al}{\forgetreft{\stype_{\al}}}}
      {\al'}{\forgetreft{\subst{\stype'}{\al}{\stype_{\al}}}}
    = \subst{\subst{\sftype'}{\al'}{\forgetreft{t'}}}{\al}{\forgetreft{\stype_{\al}}}$.
  %
  Therefore, we conclude that 
  $\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
    {\subst{\sexpr}{\al}{\stype_{\al}}}
    {\subst{\sftype}{\al}{\forgetreft{\stype_{\al}}}}$.
  %%
  \pfcase{\fTAbs}: TODO typesetting
  %%
%{\bf Case} {\sc T-AbsT}:We have $\Gamma', x:t_x,\Gamma \vdash e : t$ where $e \equiv \Lambda \al:k. e'$ and $t \equiv \polytype{\al}{k}{t'}$. By inversion, $\al'\bind k, \Gamma', x\bind t_x,\Gamma \vdash e'[\al'/\al] : t'[\al'/\al]$ and $\al'\bind k, \Gamma', x\bind t_x,\Gamma \vdash_w t'[\al'/\al] : k'$ for some $\al'\not\in\dom{\Gamma}$. By the inductive hypothesis
%\begin{equation}
%\al'\bind k, \Gamma'[v_x/x],\Gamma \vdash e'[\al'/\al][v_x/x] : t'[\al'/\al][v_x/x] \;\;{\rm and}\;\; \al'\bind k, \Gamma'[v_x/x],\Gamma \vdash_w t'[\al'/\al][v_x/x] : k'.
%\end{equation}
%We must have $x\neq \al'$ and we have $x \neq \al$ because bound and free variables are taken to be distinct. Moreover, $v_x$ contains only free variables from $\Gamma$, so $e'[\al'/\al][v_x/x] = e'[v_x/x][\al'/\al]$ and $t'[\al'/\al][v_x/x] = t'[v_x/x][\al'/\al]$. Then by rule {\sc T-AbsT}
%\begin{equation}
%\Gamma'[v_x/x], \Gamma' \vdash \Lambda \al:k.(e'[v_x/x]) : \polytype{\al}{k}{t'[v_x/x]}.
%\end{equation}
%By definition of substitution, we can rewrite the above as
%\[
%\Gamma'[v_x/x],\Gamma \vdash (\Lambda \al:k.e')[v_x/x] : \polytype{\al}{k}{t'}[v_x/x].
%\]
%In the type variable substitution lemma, where we have an environment $\Gamma',\beta\bind k_\beta,\Gamma$ and $\Gamma \vdash_w t_\beta : k_\beta$ this proof is similar except that we argue that $e'[\al'/\al][t_\beta/\beta] = e'[t_\beta/\beta][\al'/\al]$ and $t'[\al'/\al][t_\beta/\beta] = t'[t_\beta/\beta][\al'/\al]$ because $\al'\neq\beta$ and only free variables from $\Gamma$ may appear in $t_\beta$.

%% 
\pfcase{\fLet}: We have $\sexpr \equiv \eletin{x}{\sexpr_1}{\sexpr_2}$
and by inversion we have that for some type $\sftype_1$,
$\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sexpr_1}{\sftype_1}$
and for some $\notmem{y}{\tcenv', \bind{\al}{k_{\al}}, \tcenv}$,
$\hasftype{\bind{y}{\sftype_1},\tcenv', \bind{\al}{k_{\al}}, \tcenv}
{\subst{\sexpr_2}{x}{y}}{\sftype}$.
By the inductive hypothesis, we have that
$\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
{\subst{\sexpr_1}{\tvar}{\stype_\tvar}}{\subst{\sftype_1}{\tvar}{\forgetreft{\stype_\tvar}}}$
and\\
$\hasftype{\bind{y}{\subst{\sftype_1}{\tvar}{\stype_\tvar}},\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
{\subst{\sexpr_2}{x}{\stype_\tvar}}{\subst{\sftype}{\tvar}{\forgetreft{\stype_\tvar}}}$.
Then by rule \fLet we conclude\\
$\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
{\eletin{x}{\subst{\sexpr_1}{\tvar}{\stype_\tvar}}{\subst{\sexpr_2}{\tvar}{\stype_\tvar}}}{\subst{\sftype}{\tvar}{\forgetreft{\stype_\tvar}}}$.
%%
\pfcase{\fAnn}: We have $\sexpr \equiv \tyann{\sexpr'}{\stype}$ 
and by inversion we have that $\forgetreft{\stype} = \sftype$ and 
$\hasftype{\tcenv', \bind{\al}{k_{\al}}, \tcenv}
{\sexpr'}{\sftype}$.
By the inductive hypothesis, we have
$\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
{\subst{\sexpr'}{\tvar}{\stype_\tvar}}{\subst{\sftype}{\tvar}{\forgetreft{\stype_\tvar}}}$.
By our definition of refinement erasure, we have
$\forgetreft{\subst{\stype}{\tvar}{\stype_\tvar}}
 = \subst{\forgetreft{\stype}}{\tvar}{\forgetreft{\stype_\tvar}}$
and we have 
$\subst{\tyann{\sexpr'}{\stype}}{\tvar}{\stype_\tvar} 
 = \tyann{\subst{\sexpr'}{\tvar}{\stype_\tvar}}{\subst{\stype}{\tvar}{\stype_\tvar}}$. Thus by rule \fAnn,
$\hasftype{\subst{\tcenv'}{\al}{\forgetreft{\stype_{\al}}}, \tcenv}
{\subst{\tyann{\sexpr'}{\stype}}{\tvar}{\stype_\tvar}}{\subst{\forgetreft{\stype}}{\tvar}{\forgetreft{\stype_\tvar}}}$.
%%
\pfcase{\fIf}: TODO Typesetting
%%
\end{proof}  

%\NV{Edited, Michael check}
%The proof goes by induction on the derivation tree. 
Because we encoded our typing rules using 
cofinite quantification % (\S~\ref{sec:lang:static})
the proof above does not require a renaming lemma, but 
the rules that lookup environments 
(rules \tVar and \wtVar) do need a \emph{Weakening Lemma}:
%\Cref{lem:weakeningF}. 
% and \emph{rename} free variables 
%in typing and well-formedness judgments (\cref{lem:freevarsF}).

\begin{lemma}(Weakening) \label{lem:weakeningF}
If $\hasftype{\tcenv_1,\!\tcenv_2\!}{\!\sexpr\!}{\!\sftype}$ and 
   $x,\!\al\! \not\in\! {\tcenv_1, \!\tcenv_2}$,
then 
\begin{enumerate} 
    \item 
    \hasftype{\tcenv_1,\!\bind{x}{\sftype_x},\!\tcenv_2}{\!\sexpr\!}{\!\sftype}, and
    \item 
    \hasftype{\tcenv_1,\!\bind{\al}{\skind},\!\tcenv_2}{\!\sexpr\!}{\!\sftype}.
\end{enumerate}
\end{lemma}
%
The proof is fairly similar to the proof of the Substitution Lemma above,
and we omit it here.


% \begin{proof}
% The proof is by straightforward structural induction on the derivation trees of $\sysf$ typing judgments, weakening the typing and well-formedness judgments in the antecedents. Where needed, we apply the Change of Variables Lemma below to ensure that anything we add to the environment is distinct from the larger, weakened environment.
% \end{proof}

% We also use the lemma that types in typing judgments are well-formed. 

% The proof of the substitution lemma 
% depends on the Weakening Lemma and 
% the Change 
% of Variables Lemma which allow us to 
% perform certain technical manipulations 
% on judgments. 
% %
% Each of these three lemmas has versions 
% that apply to both typing judgments and 
% well-formedness judgments.

% Lemma \ref{canonicalF} further determines all of the possibilities for well-typed closed values; any other well-typed closed term can be further evaluated. The preservation theorem
% also relies on Definition \ref{primitivesF} that types are preserved under the defined semantics for the built-in primitives.
% The main technical challenge in the preservation theorem arises when 
% our closed term has the form $\app{(\vabs{x}{\sexpr})}{\sval}$
% or $\tyapp{(\tabs{\al}{\skind}{\sexpr})}{\stype}$;
% the next step of the evaluation requires substituting 
% for a term variable or type variable 
% in the abstraction body $e$, and in the latter case of a type abstraction, 
% substituting in the type itself. 
% The relationship between a valid substitution and a typing
% judgment is given in the Lemma \ref{substitutionF}, the Substitution Lemma. 
% Two technical lemmas are required to prove the substitution lemma; 
% these are stated in Lemmas \ref{freevarsF} and \ref{weakeningF}.  
% The appearance of well-formedness judgments in our typing rules 
% require us to prove versions of these lemmas 
% for well-formedness judgments in Lemma \ref{WFFTlemmas} 
% and to generate well-formedness judgments from typing judgments in Lemma \ref{ftypes-wfft}.



% \begin{proof}
%     The proof is by straightforward mutual induction 
%     on the derivation trees of each typing judgment, 
%     using the well-formedness version %and (\ref{ftypes-wfft}) 
%     where needed.
% \end{proof}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CUT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Use this??
%We begin by proving the main sequence of lemmas for judgments on the well-formedness of $\sysf$ types. The Free Variables lemmas are proven by mutual structural induction for the term and type variables versions.
% 
%     \begin{lemma}\label{WFFTlemmas}
%         For any $\sysf$ environments $\tcenv$, $\tcenv'$ and $x,y,\al,\al' \not\in \dom{\tcenv', \tcenv}$:
%         \item (Free Variables) 
%             If $\isWFFT{\tcenv',\bind{x}{\sftype_x},\tcenv}{\sftype}{\skind}$ 
%             then $\isWFFT{\tcenv', \bind{y}{\sftype_x} \tcenv}{\sftype}{\skind}$.
%             If $\isWFFT{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sftype}{\skind}$, 
%             then $\isWFFT{\tcenv', \bind{\al'}{k_{\al}}, \tcenv}{\subst{\sftype}{\al}{\al'}}{\skind}$. 
%         \item (Weakening) If $\isWFFT{\tcenv', \tcenv}{\sftype}{\skind}$
%             then $\isWFFT{\tcenv', \bind{x}{\sftype_x}, \tcenv}{\sftype}{\skind}$ 
%             and $\isWFFT{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sftype}{\skind}$.
%         \item (Substitution Lemma) 
%             If $\isWFFT{\tcenv', \bind{\al}{k_{\al}}, \tcenv}{\sftype}{\skind}$ and
%             $\isWFFT{\tcenv}{\sftype_{\al}}{k_{\al}}$  
%             then $\isWFFT{\subst{\tcenv'}{\al}{\sftype_{\al}},\tcenv}{\subst{\sftype}{\al}{\sftype_{\al}}}{\skind}$.
%     \end{lemma}

% (don't use these probably)   
% We can also prove analogous statements for the well-formedness judgments for $\sysf$ environments. These judgments never appear in the antecedent positions in any of our $\sysf$ type well-formedness of $\sysf$ typing rules, so they are not part of the chain of logical dependencies. However, they are used in the full metatheory in order to prove facts about closing substitutions.
% 
% Because some $\sysf$ typing judgments have a well-formedness judgment in an antecedent position, we often need to generate a well-formedness judgment for a $\sysf$ type that appears in a typing judgment:
%     
% \begin{lemma}\label{ftypes-wfft}
%     (Well-formedness of $\sysf$ types in judgments) 
%     If $\hasftype{\tcenv}{\sexpr}{\sftype}$ and $\isWFFE{\tcenv}$ 
%     then $\isWFFT{\tcenv}{\sftype}{\skstar}$.
% \end{lemma}
%
% \begin{proof}
% The proof is by structural induction on the typing judgment. In some of the inductive cases we need to use the Weakening lemma above, as well as a strengthening lemma that says we can drop any term variable from the environment because $\sysf$ types cannot contain term variables (no refinements or dependent arrows.)
% \end{proof}
%
% We start the main sequence of lemmas with a lemma that allows us to rename free variables at will. Although this is intuitively obvious, it is required in the proof of the weakening lemma below. Unlike other traditional approaches to System F metatheory \cite{TAPL}, we do not prove a permutation lemma that would allow us to re-order the environment under restricted circumstances.,


% REMOVED FIGURES
% \begin{figure}
%     \begin{tabular}{rrcll}
%     \emphbf{Kinds} 
%       & \skind & $\bnfdef$ & \skbase & \emph{base kind} \\
%       &        & $\spmid$  & \skstar & \emph{star kind} \\[0.05in]
%     
%     \emphbf{Base Types} 
%       & \sbase & $\bnfdef$ & $\tbool$ & \emph{booleans} \\
%       &        & $\spmid$  & $\tint$  & \emph{integers} \\
%       &        & $\spmid$  & $\tvar$  & \emph{type variables} \\[0.05in]
%     
%     \emphbf{Types}
%       & \sftype & $\bnfdef$ & $\sbase$                        & \emph{base type} \\ 
%       &         & $\spmid$  & $\funcftype{\tau}{\tau'}$       & \emph{function type}  \\        
%       &        & $\spmid$  & $\polytype{\tvar}{\skind}{\tau}$ & \emph{polymorphic type}  \\ [0.05in]        
%     
%     \emphbf{Environments}
%       & $\tcenv$ & $\bnfdef$ & $\varnothing$                  & \emph{empty environment} \\
%       &          & $\spmid$  & $\tcenv, \bind{x}{\sftype}$       & \emph{variable binding} \\
%       &          & $\spmid$  & $\tcenv, \bind{\tvar}{\skind}$ & \emph{type binding} \\
%     \end{tabular}
%     \caption{Syntax of $\sysf$ Types and Environments}
%     \label{fig:syn:ftypes}
%     \label{fig:syn:fenv}
%     \end{figure}

%
% First, rule \wfftBasic states that the two closed base types (\tint and \tbool)
% are well-formed and have base kind in any context.
%
% Similarly, rule \wfftVar says that
% type variable $\tvar$ is well-formed having kind $\skind$
% so long as $\bind{\tvar}{\skind}$ is bound in the environment.
%
% Next, our rule \wfftFunc states that 
% a function type $\funcftype{\sftype_x}{\sftype}$
% is well-formed with star kind in some environment $\tcenv$ if 
% both types $\sftype_x$ and $\sftype$ are
% well-formed (with any kind) in the same environment.
%
% Next, rule \wfftPoly establishes that a 
% polymorphic type $\polytype{\tvar}{\skind}{\sftype}$
% has star kind in environment $\tcenv$ if the 
% inner type $\stype$ is well-formed (with any kind)
% in environment $\tcenv$ augmented by binding a fresh
% type variable $\tvar$ to kind $\skind$.
%
% Finally, rule \wfftKind simply states that if a type $\sftype$
% is well-formed with base kind in some environment, then 
% it is also well-formed with star kind in that environment.
%
% As for environments, rule \wffeEmp states that the empty environment 
% is well-formed. Rule \wffeBind says that a well-formed environment
% $\tcenv$ remains well-formed after binding a fresh variable $x$ to any
% type $\sftype_x$ that is well-formed in $\tcenv$.
%
% Finally rule \wffeTBind states that a well-formed environment remains
% well-formed after binding a fresh type variable to any kind.
% 
%     \begin{figure}
%     \judgementHead{Well-formed Type}{\isWFFT{\tcenv}{\sftype}{\skind}}
%     \begin{mathpar}      %%%%%%%%%%%% SYSTEM F WELL-FORMEDNESS %%%%%%%%%%%%%
%         \inferrule*[Right=\wfftBasic]{b\in\{\Bool,\Int\}}
%                     {\isWFFT{\tcenv}{b}{\skbase}}\and
%         \inferrule*[Right=\wfftVar]{\bind{\tvar}{\skind} \in \tcenv}
%                     {\isWFFT{\tcenv}{\tvar}{\skind}}\\
%         \inferrule*[Right=\wfftFunc]
%         {\isWFFT{\tcenv}{\sftype_x}{k_x} \quad\; \isWFFT{\tcenv}{\sftype}{k}}
%         {\isWFFT{\tcenv}{\funcftype{\sftype_x}{\sftype}}{\skstar}} \\
%         \inferrule*[Right=\wfftPoly]
%         {\isWFFT{\bind{\al'}{k}, \tcenv}{\subst{\al}{\al'}{\sftype}}{k_\sftype} 
%             \quad \notmem{\al'}{\dom{\tcenv}} }
%         {\isWFFT{\tcenv}{\polytype{\al}{k}{\sftype}}{\skstar}} \and
%         \inferrule*[Right=\wfftKind]{\isWFFT{\tcenv}{\sftype}{\skbase}}
%             {\isWFFT{\tcenv}{\sftype}{\skstar}} \\
%     \end{mathpar}
%    
%     \judgementHead{Well-formed Environment}{\isWFFE{\tcenv}}
%     \begin{mathpar}
%         \inferrule*[Right=\wffeEmp]{ }{\isWFFE{\varnothing}} \and
%     %
%         \inferrule*[Right=\wffeBind]{\isWFFT{\tcenv}{\sftype_x}{k_x}  \quad 
%           \isWFFE{\tcenv} \quad \notmem{x}{\dom{\tcenv}}}
%           {\isWFFE{\bind{x}{\sftype_x},\tcenv}} \\
%     %
%         \inferrule*[Right=\wffeTBind]
%         {\isWFFE{\tcenv} \quad \notmem{\al}{\dom{\tcenv}}}
%         {\isWFFE{\bind{\al}{\skind}, \tcenv}}
%     \end{mathpar}
%     \caption{Well-formedness of types and environments in $\sysf$}
%     \label{fig:wfft}\label{fig:wffe}
%    \end{figure}

%
% Rule \fPrim states that for any built-in primitive $\sconst$, it can be given base
% type $\forgetreft{\ty{\sconst}}$ in any context.
%
% Rule \fVar establishes that any variable $x$ bound to $\sftype$ 
% in some environment can be given the same type $\sftype$
% in that environment.
%
% Our rule \fApp states the conditions for typing a term application
% $\app{\sexpr}{\sexpr'}$. Under the same environment,
% we must be able to type $\sexpr$ at 
% some function type $\funcftype{\sftype_x}{\sftype}$ and
% $\sexpr'$ at $\sftype_x$. Then we can give $\app{\sexpr}{\sexpr'}$
% type $\sftype$.
% 
% Next, rule \fAbs says that we can type a lambda abstraction
% $\vabs{x}{\sexpr}$ at a function type $\funcftype{\sftype_x}{\sftype}$
% whenever $\sftype_x$ is well-formed and when the body $\sexpr$
% can be typed at $\sftype$ in the environment augmented by binding 
% a fresh variable to $\sftype_x$.
% 
% Our rule \fTApp states that whenever a term $\sexpr$ has polymorphic
% type $\polytype{\al}{\skind}{\sftype'}$, then for any well-formed type 
% of the form $\forgetreft{\stype}$
% with kind $\skind$ in the same environment, we can give the type
% $\subst{\sftype'}{\al}{\forgetreft{\stype}}$ 
% to the type application $\tyapp{\sexpr}{\stype}$.
% 
% The rule \fTAbs establishes that a 
% type-abstraction $\tabs{\al}{\skind}{\sexpr}$ can be given 
% a polymorphic type $\polytype{\al}{\skind}{\sftype}$ in some
% environment $\tcenv$ whenever $\sexpr$ can be given type $\sftype$ 
% in the environment $\tcenv$ augmented by binding a fresh type variable 
% to kind $\skind$.
% 
% Next, rule $\fLet$ states that an expression 
% $\eletin{x}{\sexpr_x}{\sexpr}$ has type
% $\sftype$ in some environment provided that $\sexpr_x$ can
% be given some type $\sftype_x$ and the body $\sexpr$ can be given type $\sftype$
% in the augmented environment formed by binding a fresh variable to $\sftype_x$.
% 
% Rule $\fAnn$ establishes that an explicit annotation $\tyann{\sexpr}{\stype}$
% can be given type $\forgetreft{\stype}$ when the underlying expression has 
% type $\forgetreft{\stype}$.


% \begin{figure}
%     \begin{mathpar}             %%%%%%%%%%%%% SYSTEM F TYPING %%%%%%%%%%%%%%%%%%
%         \inferrule*[Right=\fPrim]
%             {\forgetreft{\ty{\sconst}} = \sftype}
%             {\hasftype{\tcenv}{\sconst}{\sftype}}
%     %
%         \and
%     %
%         \inferrule*[Right=\fVar]
%             {\bind{x}{\sftype} \in \tcenv}{\hasftype{\tcenv}{x}{\sftype}} 
%     %
%         \and
%     %
%         \inferrule*[Right=\fApp]
%         {\hasftype{\tcenv}{\sexpr}{\funcftype{\sftype_x}{\sftype}} \qquad 
%             \hasftype{\tcenv}{\sexpr'}{\sftype_x}}
%         {\hasftype{\tcenv}{\app{\sexpr}{\sexpr'}}{\sftype} } \\
%     %
%         \inferrule*[Right=\fAbs]
%         {\hasftype{\bind{y}{\sftype_x}, \tcenv}{\subst{\sexpr}{x}{y}}{\sftype} \qquad
%          \isWFFT{\tcenv}{\sftype_x}{\skind_x}  \qquad
%          \notmem{y}{\dom{\tcenv}}}
%         {\hasftype{\tcenv}{\vabs{x}{\sexpr}}{\funcftype{\sftype_x}{\sftype}}} \\
%     %
%         \inferrule*[Right=\fTApp]
%         {\hasftype{\tcenv}{\sexpr}{\polytype{\al}{\skind}{\sftype'}} \qquad 
%          \isWFFT{\tcenv}{\forgetreft{\stype}}{\skind}}
%         {\hasftype{\tcenv}{\tyapp{\sexpr}{\stype}}{\subst{\sftype'}{\al}{\forgetreft{\stype}}}} \\
%     %
%         \inferrule*[Right=\fTAbs]
%         {\hasftype{\bind{\al'}{\skind}, \tcenv}{\subst{\sexpr}{\al}{\al'}}{\subst{\sftype}{\al}{\al'}} \qquad \notmem{\al'}{\dom{\tcenv}}}
%         {\hasftype{\tcenv}{\tabs{\al}{\skind}{\sexpr}}{\polytype{\al}{\skind}{\sftype}}} \\
%     %
%         \inferrule*[Right=\fLet]
%         {\hasftype{\tcenv}{\sexpr_x}{\sftype_x} \qquad
%          \hasftype{\bind{y}{\sftype_x},\tcenv}{\subst{\sexpr}{x}{y}}{\sftype} \qquad
%          \notmem{y}{\dom{\tcenv}}}
%         {\hasftype{\tcenv}{\eletin{x}{\sexpr_x}{\sexpr}}{\sftype}} \\
%     %
%         \inferrule*[Right=\fAnn]
%         {\hasftype{\tcenv}{\sexpr}{\sftype} \qquad \forgetreft{\stype} = \sftype}{\hasftype{\tcenv}{\tyann{\sexpr}{\stype}}{\sftype}}
%     \end{mathpar}
%     \caption{$\sysf$ typing rules}\label{fig:ft}
%     \end{figure}
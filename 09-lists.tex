\chapter{Lists: The Language \sysrfd}
\label{ch:lists}

One of the key features of GHC's core calculus
missing from $\sysrf$ is data types. The addition of
data types would also enable us to replace the ad hoc
kind system of $\sysrf$ with a more versatile system
of type classes.
%
As a first step in this direction, we augment our
calculus with polymorphic refined list types.
We also add a measure @length@ that describes the 
length of our lists.

\section{Syntax and Semantics} \label{sec:lang:syntaxD}

We present the syntax and semantics of \sysrfd in terms 
of the additions to \sysrf. The reader may refer to 
the figures in Chapter \ref{ch:language} for the syntactic
forms and rules that are inherited from \sysrf.
%
As before, we use the $\greybox{\mbox{grey}}$ to highlight
the extensions to $\sysf$ needed to support refinements 
in $\sysrfd$.

\begin{figure}%[t!]
%  \scalebox{0.80}{
    \begin{tabular}{rrcll}
\emphbf{Primitives} 
  & \sconst & $\bnfdef$ & $\cdots$    & \\ %\emph{booleans and integers} \\
  &         & $\spmid$  & $\suc$     & \emph{integer ops.} \\
  &         & $\spmid$  & $\len$      & \emph{polymorphic list ops} \\ [0.05in] 

\emphbf{List Values}
  & \slval  & $\bnfdef$ & $\nil{\stype}$  & \emph{empty list} \\
  &         & $\spmid$  & $\cons{\stype}{\sval}{\slval}$  
                                      & \emph{list constructor} \\ [0.05in]
\emphbf{Values}
  & \sval   & $\bnfdef$ & $\cdots$               & \\ % \emph{primitives} \\ 
  &         & $\spmid$  & \slval                & \emph{list values} \\[0.05in]

\emphbf{Terms}
  & \sexpr  & $\bnfdef$ & $\cdots$              & \\ %\emph{values} \\ 
  &         & $\spmid$  & \cons{\stype}{e_1}{e_2} & \emph{list constructor} \\
  &         & $\spmid$  & \eswitch{e}{e_n}{e_c} & \emph{list destructor} \\
\end{tabular}
%  }
  \vspace{-0.0cm}
  \caption{Syntax of Primitives, Values, and Expressions.}
\label{fig:syn:termsD}
\vspace{-0.0cm}
\end{figure}


\begin{figure}%[b!]
%{\small
  \begin{tabular}{rrcll}

  \emphbf{Types}
   & \stype & $\bnfdef$ & $\cdots$              & \\ %\emph{values} \\ 
   &        & $\spmid$  & $\listtype{\stype}\greybox{\!\breft{}{\vv}{\spred}}$  & \emph{\greytextbox{refined} list type} \\ 
  \end{tabular}
%}
\vspace{-0.0cm}
  \caption{Syntax of Types.
           The grey boxes are the extensions 
           to $\sysf$ needed by $\sysrfd$.}
           %We use $\sftype$ for $\sysf$-only types.}
  \label{fig:syn:typesD}
  \vspace{-0.00cm}
\end{figure}

\mypara{Constants, Values, and Terms}
%
\Cref{fig:syn:termsD} summarizes the syntax of terms in both 
\sysrfd and in the unrefined calculus.
%
The \emph{primitives} $\sconst$ now
include a $\suc$ function on integers that adds one
and a (polymorphic) $\len$ measure that computes the length of any list.
%
Although a user could easily define $\len$ using
\texttt{switch} below, we add $\len$ as a built-in primitive
in order to use it in our typing judgments.
%
Our \emph{terms} $\sexpr$ now additionally contain two list constructors:
the empty list $\nil{\stype}$ and the non-empty $\cons{\stype}{\sexpr_1}{\sexpr_2}$,
which builds a list from a head element and a tail.
%
Both of these constructors take a refined type annotation. For instance, we should
be able to type check
\[
\cons{\breft{\tint}{\vv}{\vv\geq 0}}{1}({\cons{\breft{\tint}{\vv}{\vv > 0}}{2}{3}})
\]
but not
\[
\cons{\breft{\tint}{\vv}{\vv > 0}}{1}({\cons{\breft{\tint}{\vv}{\vv\geq 0}}{2}{3}})
\]

because the tail of the latter list is only known to consist of non-negative integers.
%
Although we mechanized the metatheory in the same manner without 
type annotations as well, these annotations are needed to enable 
the birdirectional type checking algorithm described in Chapter \ref{ch:bidirectional}.
%
The terms also now contain a list destructor 
$\eswitch{\sexpr}{\sexpr_n}{\sexpr_c}$, which
case splits on the shape of the match scrutinee $\sexpr$.
%
Finally \emph{values} $\sval$ are augmented by lists that contain only
values as elements; these list values are defined inductively 
in Figure \ref{fig:syn:termsD}.

\mypara{Kinds \& Types}       
%
\Cref{fig:syn:typesD} shows the syntax of the types,
with the grey boxes indicating the extensions to $\sysf$ 
required by $\sysrfd$.
%
In contrast \sysrf, our list types are not base types,
but they can be refined.
%
Both of these are key to data types: our lists may contain
incomparable data such as lambda abstractions and so they
cannot support the polymorphic comparison operators within
our simple kind system.
%
However, refinements on lists are key to any model of
data types. We must be able to express the type of a program 
such as the following safe tail function:
\begin{code}
  tail :: forall a. {v:[a] | length v > 0 } -> [a]
  tail xs = switch (xs) error (\y ys -> ys)
\end{code}
%
\sysrfd keeps the simple kind system from \sysrf and 
enforces list types as $\skstar$-kinded to prevent the substitution
of a list type for a refined type variable. 
%
This prevents a refinment of a list type from attempting
to compare a list using one of the polymorphic list operators.


\mypara{Dynamic Semantics} %\label{sec:lang:dynamic}
\Cref{fig:opsemD} summarizes the small-step semantics 
for both calculi.

\begin{figure}
%  {\small
  \begin{mathpar} %%%%%%%%% SMALL-STEP SEMANTICS %%%%%%%%%%
    \judgementHead{Operational Semantics (ext. Figure \ref{fig:e})}{$\sexpr \step \sexpr'$}\\
        \inferrule%*[Right=\eCons]
        {\sexpr \step \sexpr'}
        {\cons{\stype}{\sexpr}{\sexpr_1} \step \cons{\stype}{\sexpr'}{\sexpr_1}}
        {\eCons} 
        \quad
        \inferrule%*[Right=\eConsV]
        {\sexpr \step \sexpr'}
        {\cons{\stype}{\sval}{\sexpr} \step \cons{\stype}{\sval}{\sexpr'}}
        {\eConsV} 
        \\
        \inferrule%*[Right=\eSwitch]
          {\sexpr \step \sexpr'}
          {\eswitch{\sexpr}{\sexpr_n}{\sexpr_c} \step \eswitch{\sexpr'}{\sexpr_n}{\sexpr_c}}
          {\eSwitch} 
        \quad
        \inferrule% *[Right=\eSwitchN]
          {   }
          {\eswitch{\nil{\stype}}{\sexpr_n}{\sexpr_c} \step \sexpr_n}
          {\eSwitchN} 
          \\
        \inferrule% *[Right=\eSwitchC]
          { }
          {\eswitch{\cons{\stype}{\sval_1}{\sval_2}}{\sexpr_n}{\sexpr_c} 
              \step \app{(\app{\sexpr_c}{\sval_1})}{\sval_2}}
          {\eSwitchC} 
        \end{mathpar}        
%    }
\caption{The small-step semantics for \sysrfd.} 
\label{fig:eD}
\label{fig:opsemD}
\end{figure}


%\mypara{Primitives}
%%
%The function $\delta(\sconst, \sval)$ 
%evaluates the application $\app{\sconst}{\sval}$ 
%of built-in monomorphic primitives.
%%
%The reductions are defined in a curried 
%manner, \ie 
%$\app{\app{\leq}{m}}{n}$ evaluates to $\delta(\delta(\leq,m),n)$. 
%%we have that $\app{\app{\leq}{m}}{n} \steps \delta(\delta(\leq,m),n)$. 
%%
%Currying gives us unary relations like $m\!\!\leq$ 
%which is a partially evaluated version of the $\leq$ relation.
%%
%The function $\delta_T(\sconst, \forgetreft{\stype})$
%specifies the reduction rules for type 
%application on the polymorphic 
%built-in primitives. % $=$ and $\leq$.
%%
%$$\begin{array}{rclrclrcl}
%\delta(\wedge,{\tt true}) & \defeq & \lambda x.\, x &
%\delta(\leq,m) & \defeq & m\!\!\leq  & 
%    \delta_T(=, \tbool) & \defeq & =  \\
%\delta(\wedge,{\tt false}) & \defeq & \lambda x.\, {\tt false}\quad\quad &
%\delta(m\!\!\leq, n) & \defeq & {\tt}(m \leq n) \quad\quad&
%\delta_T(=, \tint) & \defeq & = \\
%\delta(\neg,{\tt true}) & \defeq & {\tt false} & 
%\delta(=,m) & \defeq & m\!\!= &
%\delta_T(\leq, \tbool) & \defeq & \leq  \\
%  \delta(\neg,{\tt false}) & \defeq &  {\tt true} &
%  \delta(m\!\!=, n) & \defeq &  {\tt}(m = n) &
%  \delta_T(\leq, \tint) & \defeq & \leq  \\
%%
%%  \delta(\vee,{\tt true}) & \defeq & \lambda x.\, {\tt true} &
%%  \delta(\leftrightarrow,{\tt true}) & \defeq & \lambda x.\, x & 
%%    &  & \\
%%    \delta(\vee,{\tt false}) & \defeq & \lambda x.\, x &
%%    \delta(\leftrightarrow,{\tt false}) & \defeq & \lambda x.\, \neg x &
%%    & & \\
%\end{array}$$
         
\mypara{Typing and Well-formedness}
%
Next, we present the static semantics of \sysrfd by describing
the additional rules used to establish our
well-formedness, typing, and subtyping judgments.
%%
%We use $\greybox{\mbox{grey}}$ to highlight the antecedents and rules
%specific to $\sysrf$.
%%
%
\Cref{fig:wfD} summarizes the new rules
that establish the well-formedness of types.
%
Rule \wtList states that a the list type 
$\breft{\tlist{\stype}}{x}{\ttrue}$
with empty refinement
is well-formed with star kind provided that 
$\stype$ is well-formed with some kind $\skind$.
%
Similar to rule \wtRefn, our rule \wtListR 
stipulates that a refined list type $\breft{\tlist{\stype}}{x}{\spred}$
is well-formed with star kind in some environment
if the trivally refined type $\breft{\tlist{\stype}}{x}{\ttrue}$
has star kind in the same environment and if
the refinement predicate $\spred$ has type $\tbool$
in the environment augmented by binding a fresh variable to type $\tlist{\stype}$.

\begin{figure}%[t!]
%
%{\small
\begin{mathpar}
\judgementHead{Well-formed Type (ext. Figure \ref{fig:wf})}{\isWellFormed{\tcenv}{\stype}{\skind}}

%%%%%%%%%%%% WELL-FORMEDNESS %%%%%%%%%%%%%
%
\inferrule% *[Right=\wtList]
    {\isWellFormed{\tcenv}{\stype}{\skind}}
    {\isWellFormed{\tcenv}{\tlist{\stype}\greybox{\!\breft{}{x}{\ttrue}}\!}{\skstar}}
    {\wtList}
\quad
%    
\greybox{\inferrule% *[Right=\;\;\wtListR]
    { \isWellFormed{\tcenv}{\breft{\tlist{\stype}}{x}{\ttrue}}{\skstar} \\\\
      \forall\notmem{y}{\tcenv}.
      \hasftype{\bind{y}{\tlist{\stype}}, \forgetreft{\tcenv}}{\subst{p}{x}{y}}{\tbool}
    }
    {\isWellFormed{\tcenv}{\breft{\tlist{\stype}}{x}{p}}{\skbase}}
    {\wtRefn} }
%
\end{mathpar}
%}
\vspace{-0.00cm}
\caption{Well-formedness of $\sysrfd$ types. The rules for
  $\sysf$ exclude the grey boxes.}
\label{fig:wfD}
\vspace{-0.00cm}
\end{figure}

%The judgment $\hastype{\tcenv}{\sexpr}{\stype}$ states
%that the term $\sexpr$ has type $\stype$ in the context of
%environment $\tcenv$.
\Cref{fig:typingD} summarizes
the rules that establish typing for both $\sysf$ and
$\sysrf$, with grey %boxes
%indicating extensions needed
for the $\sysrf$ extensions.
%
Rule $\tNil$ states that whenever $\stype$ is a well-formed
type in some environment, then  $\nil{\stype}$ has the type
$\breft{\tlist{\stype}}{x}{\len x = 0}$ of lists of elements
of type $\stype$ of length zero.
%
The rule $\tCons$ is slightly more complex: whenever $\sexpr_h$
can be given type $\stype$ in some environment, and whenver
$\sexpr_t$ can be given type
$\breft{\tlist{\stype}}{x}{\spred}$ in the same environment,
then the list $\cons{\stype}{\sexpr_h}{\sexpr_t}$ can be given
the type $\tlist{\stype}$ with the refinement that says that
this list has length one more than some list of type
$\breft{\tlist{\stype}}{x}{\spred}$.
%
The purpose of this refinement is to embed the information about
the specific length of a list at the refinement level.
%
Our typing rule for the list destructor 
$\eswitch{\sexpr}{\sexpr_n}{\sexpr_c}$ is 
best thought of as analogous to our rule $\tIf$
because it enables path-sensitive reasoning about lists.
%
This rule $\tSwitch$ says that whenever the match scrutinee
$\sexpr$ can be given a list type 
$\breft{\tlist{\stype}}{x}{\spred}$ in some environment,
whenever $\stype'$ is well-typed in the same environment,
and whenver each branch can be given this type
$\stype'$ in this environment augmented by the knowledge 
that the about the scrutinee and its length, then the full
term $\eswitch{\sexpr}{\sexpr_n}{\sexpr_c}$ can be given type
$\stype'$. 
%
Note that, per the semantics in \ref{fig:eD}, the cons-branch
$\sexpr_c$ is a function expecting two arguments: the head
of the scrutinee and the tail (which we know has length
one less than the scrutinee).
%
In our formalism, it is neccessary for us to augment the 
environment with \emph{two} dummy variables here. We need
to preserve $\spred$,
the knowledge obtained from the match scrutinee,
and the fact that the scrutinee is one element longer than
the tail to which $\sexpr_c$ is being applied.
%
We could express the antecedent judgment as
\begin{equation}
  \label{badswitch}
\forall\notmem{z}{\tcenv}. 
  \hastype{\bind{z}{\breft{\tlist{\stype}}{x}{p},\tcenv}}
     {\sexpr_c}
     {\funcftype{\stype}{\funcftype{\tlist{\stype}\greybox{\breft{}{\vv}{\suc \len \vv = \len z}}}{\stype'}}}
\end{equation}
but this would pose a problem for proving type soundness 
for \sysrfd (specifically preservation)
from a minimal interface of axioms (\ref{lem:implicationD}) 
for implication.
%
These axioms are purely syntactic, and so are not sufficient
to prove implications (and hence subtyping obligations) 
where there are slight variations in refinement syntax. 
%
Rule \tCons gives us a refinement that says the length of this list
is one \emph{longer} than some other list;
judgment \ref{badswitch} would require us to show that the second
argument to $\sexpr_c$ has length one \emph{shorter} than some other 
list. There is no way to derive this knowledge without either a 
semantic notion of entailment, or a large, unwieldy set of axioms,
or by changing the form of rule \tSwitch as we did.


\begin{figure}
%  {\small
  \begin{mathpar}             %%%%%%%%%%%%% TYPING %%%%%%%%%%%%%%%%%%
  \judgementHead{Typing (ext. Figure \ref{fig:t})}{\hastype{\tcenv}{\sexpr}{\stype}} \\

    %
        \inferrule
        {\isWellFormed{\tcenv}{\stype}{\skind}}
        {\hastype{\tcenv}{\nil{\stype}}{\tlist{\stype}\greybox{\breft{}{x}{\len x = 0}}}}
        {\tNil}
    %
    \\  
    %
        \inferrule
        {\hastype{\tcenv}{\sexpr_h}{\stype} \\
         \hastype{\tcenv}{\sexpr_t}{\tlist{\stype}\greybox{\breft{}{x}{\spred}}}
        }
        {\hastype{\tcenv}{\cons{\stype}{\sexpr_h}{\sexpr_t}}
                 {\greybox{\existype{y}{\tlist{\stype}\greybox{\breft{}{x}{\spred}}}}
                  \tlist{\stype}\greybox{\breft{}{\vv}{\len \vv = \suc \len y}}}}
        {\tCons}
    \\    
    %
    {\small
        \inferrule
        {\hastype{\tcenv}{\sexpr}{\tlist{\stype}\greybox{\breft{}{x}{\spred}}} \\
         \isWellFormed{\tcenv}{\stype'}{\skind} \\\\
          %
         \greybox{\forall\notmem{y}{\tcenv}.}
         \hastype{\greybox{\bind{y}{\breft{\tlist{\stype}}{x}{p \wedge \len x = 0}},}\tcenv}
             {\sexpr_n}{\stype'}\\\\
          %
         \greybox{\forall\notmem{y, z}{\tcenv}.}
         \hastype{\greybox{\bind{z}{\breft{\tlist{\stype}}{x}{p \wedge \suc \len y = \len x}},
                          \bind{y}{\tlist{\stype}},}\tcenv}
            {\sexpr_c}{\funcftype{\stype}{\funcftype{\tlist{\stype}\greybox{\breft{}{\vv}{\len y = \len \vv}}}{\stype'}}}
        }
        {\hastype{\tcenv}{\eswitch{\sexpr}{\sexpr_n}{\sexpr_c}}{\stype'}}
        {\tSwitch} 
    }       
    \end{mathpar}
%  }
\vspace{-0.00cm}
\caption{Typing rules.
The judgment $\hasftype{\tcenv}{\sexpr}{\sftype}$ is extended by excluding the grey boxes.}
\label{fig:tD}\label{fig:typingD}
\vspace{-0.00cm}
\end{figure}

\mypara{New Primitives}
%
The function $\ty{\sconst}$, which gives the type of every
built-in primitives, is extended for the new primitives
$\suc$ and $\len$. Below we present essential
examples of the $\ty{\sconst}$ definition.
%
{\small
$$\begin{array}{rcl}
\ty{\suc} & \defeq & \functype{y}{\tint}{\breft{\tint}{v}{v = (\suc y)}} \\
\ty{\len} & \defeq & \polytype{\tvar}{\skstar}{\functype{y}{\al}{\breft{\tint}{v}{v = (\len y)}}}
\end{array}$$
}
For ease of reading, the $\len$ used in the refinements 
is the polymorphic $\len$,
but with the type applications elided.


\subsection{Subtyping}
\label{sec:typing:sub}

\Cref{fig:s} presents the new rule to establish the 
subtyping judgment ${\isSubType{\tcenv}{s}{t}}$.  
%
Rule \sList states that one list type
$\breft{\listtype{\stype_1}}{\vv}{\spred_1}$
is a subtype of another list type
$\breft{\listtype{\stype_2}}{\vv}{\spred_2}$
in some environment $\tcenv$, when
$\stype_1$ is a subtype of $\stype_2$ and 
$\spred_1$ implies $\spred_2$
in the
environment $\tcenv$ augmented  by binding
a fresh type variable to kind $\skind$.

\begin{figure}
\judgementHead{Subtyping}{\isSubType{\tcenv}{s}{t}}

\begin{mathpar}   %%%%%%%%%%%%%%%%%% SUBTYPING %%%%%%%%%%%%%%%%%%
%
  \inferrule*[Right=\sList]
  {\isSubType{\tcenv}{\stype_1}{\stype_2} \quad
    \forall\notmem{y}{\tcenv}. \;\;
    \imply{\bind{y}{\listtype{\stype_1}\{\ttrue\}},\tcenv}{\subst{p_1}{x}{y}}{\subst{p_2}{x}{y}} }
  {\isSubType{\tcenv}{\breft{\listtype{\stype_1}}{x}{\spred_1}}
                     {\breft{\listtype{\stype_2}}{x}{\spred_2}}}
\end{mathpar}
\vspace{-0.00cm}
\caption{Subtyping Rules.}
\label{fig:sD}
\label{fig:subtypingD}
%\label{fig:ent}
\vspace{-0.00cm}
\end{figure}

\mypara{Implication}
In \S~\ref{sec:typing:implication} we discussed our approach to formalizing
implication by giving both an axiomatized interface and a 
denotational implementation. 
%
First, we give the additional axioms for implication in \sysrfd.


\begin{requirement}[Implication Interface]\label{lem:implicationD}
  The implication relation satisfies the statements
  in Requirement~\ref{lem:implication} and the statements below:
  \begin{enumerate}
      \item (Exact Quantification) If
      $\hastype{\tcenv}{v_x}{t_x}$ and
      $\isWellFormed{\tcenv}{t_x}{\skbase}$ and 
      $\bind{x}{\self{t_x}{v_x}{\skbase}} \in \tcenv$ 
      and $x\not\in \free{v_x}$ then
      $\imply{\tcenv}{\spred}{\subst{\spred}{x}{v_x}}$.
      %
      \item (Equal Length Quantification) If
      $\hastype{\tcenv}{\sval}{\breft{\listtype{\stype}}{x}{\spred}}$ and
      $\isWellFormed{\tcenv}{\breft{\listtype{\stype}}{x}{\spred}}{\skstar}$ and \\
      $\bind{x}{\breft{\listtype{\stype}}{x}{\len x = \len \sval \wedge \spred}} \in \tcenv$ 
      and $x\not\in \free{\sval}$ and \safeListVar{x}{q} then
      $\imply{\tcenv}{q}{\subst{q}{x}{\sval}}$\\
      and
      $\imply{\tcenv}{\subst{q}{x}{\sval}}{q}$.
  \end{enumerate}
\end{requirement}

\noindent
The first statement says that whenever 
$\bind{x}{\self{t_x}{v_x}{\skbase}}$ appears 
bound in $\tcenv$, then $x$ is effectively being
universally quantified over a type with just one
inhabitant (up to equality). Then we assume 
that a refinement $\spred$ implies $\spred$ with
all occurrences of $x$ replaced by $v_x$.
%
This is semantically valid because any encoding of 
our refinements in an external logic (such as SMT)
would map $=$ in our refinement syntax to equality.
%
And we also prove that under the denotational definition of
implication (\S~\ref{sec:typing:implication:denotational})
our syntactic primitive $=$ actually corresponds to semantic
equality, and we are thus able to show that this axiom
follows from the denotational definition.

The second statement, which we call Equal Length Quantification,
expresses the best possible analogue for lists. We cannot
appeal to Exact Quantification for any variable $x$ bound to
a list type in the environment; these types cannot be
selfified because lists cannot be compared, even for equality,
in our system.
%
However, the refinements that do occur in our system (by virtue
of appearing in our various rules) do not use the 
$\texttt{switch}$ statement to destruct lists to inspect
their contents. Rather, these refinements are entirely agnostic
about the data contained in lists and are only concerned with
the length of lists.
%
We capture this notion in the recursive function 
$\safeListVar{x}{q}$ which states that $x$ only appears 
in $q$ as the argument to the $\len$ function.
% 
If this is the case, then the only information that $q$ uses 
about $x$ is the length. The Exact Length Quantification
axiom then says that if $x$ is bound to a type that constrains
the length of $x$ to be equal to the length of a list $v$, 
then the refinement $q$ is equivalent (under implication)
to $\subst{q}{x}{v}$.

Previously, we noted in \S~\ref{sec:typing:implication:interface}
that we did not require the Exact Quantification axiom in
Assumption 1 of~\cite{Knowles09} to formalize implication in \sysrf.
% 
However, we do require it for \sysrfd in our mechanization 
to verify Requirement~\ref{lem:prim-typing} as it applies to the
length of lists.

\subsection{Denotational Semantics}
\label{sec:lists:denotational}

We extend the definition of denotations of types given
in Figure~\ref{fig:den} to define the denotation of a list type.
%
In order to define the denotation 
$\denote{\breft{\listtype{\stype}}{x}{p}}$
as the set of closed values
of the appropriate base type $\listtype{\forgetreft{t}}$
which satisfy the type's refinement predicate,
we have to take into account that there are at least two
refinements here. The entire list $\sval$ must satisfy
the refinment $\spred$, and additionally the type
$\stype$ itself may contain refinements which must
be satisfied by each of the elements of $\sval$.

\begin{figure}
$$\begin{array}{r@{\hskip 0.03in}c@{\hskip 0.03in}l}
\denote{\breft{\listtype{\stype}}{x}{p}} & \defeq &
  \setcomp{\sval}{\hasftype{\varnothing}{\sval}{\listtype{\forgetreft{\stype}}} 
  \,\wedge\, (\forall\, v_i\in v.\, v_i \in \denote{t})
  \,\wedge\, \evalsTo{\subst{p}{x}{\sval}}{\ttrue}}.
\end{array}$$
\vspace{-0.0cm}
\caption{Denotations of Types and Environments.}
\label{fig:denD}
\vspace{-0.0cm}
\end{figure}

\section{Metatheory of Lists}

Our proof of type soundness of $\sysrfd$ generally follows
the same structure as the soundness proof for $\sysrf$,
illustrated in Figure~\ref{fig:graph}.
%
However, some lemmas have additional cases that are highly 
non-trivial and add additional difficulty to the proof. 
%
For instance, we need to be able to invert typing judgments
such as 
$\hastype{\tcenv}{\cons{\stype}{\sexpr_h}{\sexpr_t}}{\stype'}$
both to obtain typing judgments for $\sexpr_h$ and $\sexpr_t$
and also to obtain a typing judgment that contains the 
knowledge about the length of $\cons{\stype}{\sexpr_h}{\sexpr_t}$,
which may have been discarded through subsumption.

We give the highlights for the metatheory of \sysrfd.


\mypara{Inversion of Typing Judgments}
\label{sec:soundnessD:inversion}
%
In \S~\ref{sec:soundness:inversion} we discussed Inversion Lemma
\ref{lem:inversion}, which allowed us to invert the typing judgment
for a term- or type-abstraction. We need to extend this 
lemma to include inverting typing judgments for lists.
%
We can then recover typing information about the head and tail 
of this list as well as information about the length of the list that
may have been lost through use of the subsumption \tSub rule.

\begin{lemma} (Inversion of $\tNil$, $\tCons$) \label{lem:inversionD} 
    (extends Lemma~\ref{lem:inversion})
    \begin{enumerate}
    \item If $\hastype{\tcenv}{\nil{\stype_0}}{\breft{\listtype{\stype}}{x}{\spred}}$
    and $\isWellFormedE{\tcenv}$,
    then $\isSubType{\tcenv}{\stype_0}{\stype}$, and
    $\isWellFormed{\tcenv}{\stype_0}{\skstar}$,\\
    and $\isSubType{\tcenv}{\breft{\listtype{\stype_0}}{x}{\len x = 0}}
          {\breft{\listtype{\stype}}{x}{\spred}}$.

    \item If $\hastype{\tcenv}{\cons{\stype_0}{v_1}{v_2}}
                  {\breft{\listtype{\stype}}{x}{\spred}}$
    and $\isWellFormedE{\tcenv}$,
    then 
    $\isSubType{\tcenv}{\stype_0}{\stype}$,
    $\isWellFormed{\tcenv}{\stype_0}{\skstar}$,
    $\hastype{\tcenv}{v_1}{\stype_0}$
    and for some refinement $q$,
    $\hastype{\tcenv}{v_2}{\breft{\listtype{\stype_0}}{x}{q}}$
    and $\isSubType{\tcenv}
          {\existype{y}{\breft{\listtype{\stype}}{x}{q}}
                    {\breft{\listtype{\stype_0}}{x}{\len x = \suc \len y}} }
          {\breft{\listtype{\stype}}{x}{\spred}}$.

  \end{enumerate}                    

\end{lemma}
%
The second statement above is important because if
$\hastype{\tcenv}{\cons{\stype_0}{v_1}{v_2}}
                  {\breft{\listtype{\stype}}{x}{\spred}}$
then we cannot get directly to a typing judgment for $v_1$
or for $v_2$. Indeed, rule \tCons gives us an existentially
quantified list of type $\listtype{\stype_0}$ with a refinement
relating the length of the list to its tail; but here $\stype$
may not even be the same as $\stype_0$, so the derivation tree
must have used one or more applications of rule \tSub.
%
The proof goes by induction on the size of the derivation tree,
 which must be finite.   

\mypara{Exact Typing}
Although we cannot apply the exact typing lemma to lists (only 
base types can be selfified), we can derive an analogous
statement in terms of equality of length.
%
whenever we can type
a list value $v$ at type $\breft{\listtype{t}}{x}{p}$ then we
also type $v$ at the type $\breft{\listtype{t}}{x}{p}$
with the refinement strengthened by $\len x = \len v$.
%
\begin{lemma} (Equal Length in Typing, compare to Lemma~\ref{lem:exact}) 
\label{lem:equalLength}
%\begin{enumerate}
  %\item If $\hastype{\tcenv}{e}{t}$, $\isWellFormedE{\tcenv}$, $\isWellFormed{\tcenv}{t}{k}$, and $\isSubType{\tcenv}{s}{t}$, then $\isSubType{\tcenv}{{\rm self}(s, v, k)}{{\rm self}(t, v, k)}$.
  %\item 
  If $\hastype{\tcenv}{v}{\breft{\listtype{t}}{x}{p}}$ and $\isWellFormedE{\tcenv}$
  then $\hastype{\tcenv}{v}{\breft{\listtype{t}}{x}{\len x = \len v \wedge p}}$. 
%\end{enumerate}
\end{lemma}


\begin{comment}

\mypara{Denotational Soundness}
\label{sec:soundness:denotationalD}
\label{sec:denot:soundnessD}

Our statement of denotational soundness remains the same as
Theorem~\ref{lem:denote-sound-first}.
%
Here we emphasize that 



\begin{lemma}\label{denote-selfification} (Selfified Denotations)
  If $\isWellFormed{\varnothing}{\stype}{\skind}$,
     $\hastype{\varnothing}{\sexpr}{\stype}$,
     $\evalsTo{\sexpr}{\sval}$ for some $\sval \in \denote{\stype}$
  then $\sval \in \denote{\self{t}{e}{k}}$.
  %(DenotationsSelfify.hs) Depends on: ${\tt lem\_typing\_wf}$
\end{lemma}

This lemma captures the intuition
that if $v \in \denote{\breft{\sbase}{x}{p}}$
(\ie if $v$ has base type $\sbase$
and $\evalsTo{\subst{p}{x}{v}}{\ttrue}$),
then we have $v \in \denote{\breft{\sbase}{x}{ p \wedge x = v}}$
as $\subst{(p \wedge x=v)}{x}{v}$ certainly evaluates to $\ttrue$.
%
The full proof also handles the case that $t$
is an existential type as well as selfification
by an expression $e$ that evaluates to $v$.

\end{comment}

\section{Implementation}

We implemented the metatheory of \sysrfd in \coq.
This mechanization 
proves both type safety and
denotation soundness. 
%
Compared to mechanization of \sysrf, this proof
was about $30\%$ longer in lines of code and takes
about twice as long (two minutes) to check.
%
This mechanization is also included as supplementary
material.
%
\Cref{fig:empiricalD} summarizes the development 
of our metatheory, and points to which areas of the 
proof increased the most. 


\begin{comment}
\chapter{Soundness of \sysrf} 
\label{ch:soundness}







\section{Type Safety}
\label{sec:soundness:safety}

The type safety theorem  states that a well-typed 
term does not get stuck: \ie either 
evaluates to a value or can step 
to another term (progress) 
of the same type (preservation).
%

\begin{theorem} (Type Safety of \sysrf) 
\label{lem:soundness} 
\begin{enumerate}
    \item (Type Safety)
    If $\hastype{\varnothing}{\sexpr}{\stype}$ and $\evalsTo{\sexpr}{\sexpr'}$,
    then $\sexpr'$ is a value or $\sexpr' \step \sexpr''$
    %and $\hastype{\varnothing}{\sexpr''}{\stype}$
    for some $\sexpr''$.
    \item (No Error)
    If $\hastype{\varnothing}{\sexpr}{\stype}$ and $\evalsTo{\sexpr}{\sexpr'}$,
    then $\sexpr' \not = \eerr$.
\end{enumerate}
\end{theorem}
The No Error property explicitly states that well-typed terms 
cannot evaluate to the term $\eerr$ (that encodes stuck terms)
and is a direct implication of type safety.
We prove type safety by induction on the 
length of the sequence of steps  
$\evalsTo{\sexpr}{\sexpr'}$, using  
preservation and progress.

\mypara{Progress} \label{sec:sysf:progress}
%
The progress lemma says a well-typed term is a value 
or steps to some other term.
%
\begin{lemma} (Progress) \label{lem:progressF} 
If $\hastype{\varnothing}{\sexpr}{\stype}$, 
then $\sexpr$ is a value or $\sexpr \step \sexpr'$ for some $\sexpr'$.
\end{lemma}

The proof is by induction on the typing derivation 
using the primitives~\Cref{lem:prim-typing}, that we proved 
for our built-in primitives, and the inversion of typing lemma.



\mypara{Preservation} \label{sec:sysf:preservation}
%
The preservation lemma states that typing is preserved
by evaluation.
%
\begin{lemma} (Preservation) \label{lem:preservationF} 
If $\hastype{\varnothing}{\sexpr}{\stype}$ and $\sexpr \step \sexpr'$, 
then $\hastype{\varnothing}{\sexpr'}{\stype}$.
\end{lemma}    

The proof is by structural induction on the 
derivation of the typing judgment and implicitly uses the 
inversion lemma. 
We use the determinism of the operational 
semantics (lemma~\ref{lem:step-determ}) and 
the canonical forms lemma to case split 
on $\sexpr$ to determine $\sexpr'$.
%
The interesting cases are for \fApp and \fTApp that require 
a substitution~\Cref{lem:subst}.
%
Next, let's see the three main lemmas used in 
the preservation and progress proofs.

\section{Substitution Lemma}
\label{sec:soundness:substitution}

%The main result in the \colsubtyping
%region of~\Cref{fig:graph} is
%the substitution lemma.
%
In $\sysrf$, unlike unrefined calculi such as $\sysf$, 
typing and subtyping are mutual dependent. 
%
Due to this dependency, both the substitution
the weakening lemmas
must now be proven
in a mutually recursive form: %  for both judgments: 

\begin{lemma}\label{substitution} \label{lem:subst} (Substitution)
    \begin{enumerate}
        %If $\entails{\tcenv',\bind{\al}{\skind}\tcenv}{p}$ and $\vdash_w \tcenv',\bind{\al}{\skind}\tcenv$ and $\hastype{\tcenv}{t_a}{k}$ then $\entails{\subst{\tcenv'}{\al}{t_\al},\tcenv}{p[t_a/a]}$. (SubstitutionLemmaEntTV.hs) \\
        \item If $\isSubType{\tcenv_1,\bind{x}{t_x},\tcenv_2}{s}{t}$,
                 $\isWellFormedE{\tcenv_2}$,
            and $\hastype{\tcenv_2}{v_x}{t_x}$,
            then $\isSubType{\subst{\tcenv_1}{x}{v_x},\tcenv_2}{\subst{s}{x}{v_x}}{\subst{t}{x}{v_x}}$.
            %(SubstitutionLemmaTyp.hs) Our ${\tt lem\_subst\_sub}$ depends on ${\tt lem\_subst\_ent}$. \\
        \item If $\hastype{\tcenv_1,\bind{x}{t_x},\tcenv_2}{e}{t}$,
                 $\isWellFormedE{\tcenv_2}$,
            and $\hastype{\tcenv_2}{v_x}{t_x}$,
            then $\hastype{\subst{\tcenv_1}{x}{v_x},\tcenv_2}{\subst{e}{x}{v_x}}{\subst{t}{x}{v_x}}$.
            % (SubstitutionLemmaTyp.hs) Mutually recursive with ${\tt lem\_subst\_sub}$. \\
        \item If $\isSubType{\tcenv_1,\bind{\al}{\skind},\tcenv_2}{s}{t}$,
                $\isWellFormedE{\tcenv_2}$,
            and $\isWellFormed{\tcenv_2}{t_\al}{k}$,
            then $\isSubType{\subst{\tcenv_1}{\al}{t_\al},\tcenv_2}{\subst{s}{\al}{t_\al}}{\subst{t}{\al}{t_\al}}$.
            %(SubstitutionLemmaTypTV.hs) Our ${\tt lem\_subst\_tv\_sub}$ depends on ${\tt lem\_subst\_tv\_ent}$.\\
        \item If $\hastype{\tcenv_1,\bind{\al}{\skind},\tcenv_2}{e}{t}$,
                 $\isWellFormedE{\tcenv_2}$,
            and $\isWellFormed{\tcenv_2}{t_\al}{\skind}$,
            then $\hastype{\subst{\tcenv_1}{\al}{t_\al},\tcenv_2}{\subst{e}{\al}{t_\al}}{\subst{t}{\al}{t_\al}}$.
        %(SubstitutionLemmaTypTV.hs) Mutually recursive with ${\tt lem\_subst\_tv\_sub}$.
    \end{enumerate}
\end{lemma}

The proof goes by induction on the derivation trees. 
The main difficulty arises
in substituting some type
$t_\al$ for variable $\al$
in $\isSubType{\tcenv_1,\bind{\al}{\skind},\tcenv_2}{\breft{\al}{x_1}{p}}{\breft{\al}{x_2}{q}}$
because $t_\al$  must be
strengthened  by
the refinements $p$ and
$q$ respectively.
%
Because we encoded our typing rules using 
cofinite quantification~\cite{AydemirCPPW08}
the proof does not require a renaming lemma, but 
the rules that lookup environments 
(rules \tVar and \wtVar) do need a \emph{weakening Lemma}:
%\Cref{lem:weakeningF}. 
% and \emph{rename} free variables 
%in typing and well-formedness judgments (\Cref{lem:freevarsF}).

%As with the $\sysf$ version, the proof 
%requires the \emph{Weakening}~\Cref{lem:weakening}
%but now both for typing and subtyping.

%\RJ{where is "weakening" used? the label is unused in the text. CUT or REFER}
\begin{lemma}\label{lem:weakening} (Weakening)
If $\notmem{x,\al}{{\tcenv_1, \tcenv_2}}$, then
    \begin{enumerate}
        \item if $\hastype{\tcenv_1, \tcenv_2}{\sexpr}{\stype}$
        then $\hastype{\tcenv_1, \bind{x}{\stype_x}, \tcenv_2}{\sexpr}{\stype}$ and $\hastype{\tcenv_1, \bind{\al}{\skind}, \tcenv_2}{\sexpr}{\stype}$.
        \item if $\isSubType{\tcenv_1, \tcenv_2}{s}{t}$
        then $\isSubType{\tcenv_1, \bind{x}{\stype_x}, \tcenv_2}{s}{t}$
        and $\isSubType{\tcenv_1, \bind{\al}{\skind}, \tcenv_2}{s}{t}$.
            %\item If $\tcenv', \tcenv \vdash_e p$ then $\tcenv', \bind{x}{t_x}, \tcenv \vdash_e p$ and $\tcenv', \al\bindt k, \tcenv \vdash_e p$.
            %\item If $\tcenv', \tcenv \vdash_w t:k$ then $\tcenv', \bind{x}{t_x}, \tcenv     \vdash_w t:k$ and $\tcenv', \al\bindt k, \tcenv \vdash_w t:k$.
    \end{enumerate}
\end{lemma}

The proof is by mutual induction
on the derivation of the typing and subtyping judgments.

\section{Narrowing} 
\label{sec:soundness:narrowing}

The narrowing lemma says that whenever
we have a judgment where a binding
$x\bindt t_x$ appears in the binding
environment, we can replace $t_x$
by any subtype $s_x$.
%
The intuition here is that the judgment
holds under the replacement because we
are making the context more specific.

\begin{lemma} \label{subtype-env} \label{lem:narrowing} (Narrowing)
    If $\tcenv_2 \vdash s_x <: t_x$,  $\isWellFormed{\tcenv_2}{s_x}{k_x}$,
    and $\isWellFormedE{\tcenv_2}$ then
    \begin{enumerate}
        \item if $\tcenv_1, \bind{x}{t_x}, \tcenv_2 \vdash_w t : k$, then
                 $\tcenv_1, x\bindt s_x, \tcenv_2 \vdash_w t : k $.
        \item if $\tcenv_1, \bind{x}{t_x}, \tcenv_2 \vdash t_1 <: t_2$, then
                 $\tcenv_1, x\bindt s_x, \tcenv_2 \vdash t_1 <: t_2$.
        \item if $\tcenv_1, \bind{x}{t_x}, \tcenv_2 \vdash e : t$, then
                 $\tcenv_1, x\bindt s_x, \tcenv_2 \vdash e : t$.
    \end{enumerate}
\end{lemma}

\begin{fullversion}
The narrowing proof
requires an exact typing~\Cref{lem:exact}
which says that a subtyping
judgment $\isSubType{\tcenv}{s}{t}$
is preserved after
selfification on both types.
%
Similarly 
%\NV{Put these two in one line if we need space}



% REMOVED LEMMAS

%We can also prove analogous statements for the well-formedness judgments for environments. Next, we have the weakening lemma for well-formedness judgments. As with the free variables lemma, it even suffices for the erased environments to be well-formed.

%\begin{lemma}\label{WF-weaken}
%    For any environments $\tcenv$, $\tcenv'$ and $x,\al, \not\in dom(\tcenv', \tcenv)$:
%    If $\tcenv', \tcenv \vdash_w t:k$ and $\vdash_{w} \tcenv', \tcenv$, then $\tcenv', \bind{x}{t_x}, \tcenv \vdash_w t:k$ and $\tcenv', \al\bindt k_{\al}, \tcenv \vdash_w t:k$.
%\end{lemma}

%Next, we have the substitution lemma for well-formedness judgments.

%\begin{lemma}\label{WF-substitution}
%    For any environments $\tcenv$, $\tcenv'$ and $x,\al \not\in dom(\tcenv', \tcenv)$:
%    \item If $\tcenv', \bind{x}{t_x}, \tcenv \vdash_w t:k$ and
%    $\hastype{\tcenv}{v_x}{t_x}$, then
%    then $\tcenv'[v_x/x], \tcenv \vdash_w \subst{t}{x}{v_x}:k$.
%    \item If $\tcenv', \al\bindt k_{\al}, \tcenv \vdash_w t:k$ and
%    $\isWFFT{\tcenv}{t_{\al}}{k_{\al}}$,
%    then $\tcenv'[t_{\al}/\al], \tcenv \vdash_w t[t_{\al}/\al]:k$.
%\end{lemma}

%\begin{lemma}
%    {\em Typing implies Well-Formedness}: If $\hastype{\tcenv}{e}{t}$ and $\vdash \tcenv$ then $\isWellFormed{\tcenv}{t}{{}^{*}}$. (LemmasTyping.hs) Used in many, many places.
%\end{lemma}

%    \begin{lemma}
%        {\em ``Assumption 1'' / Typing of $\delta$}. In the mechanization we  assume something more conservative and then show:  If $\hastype{\varnothing}{c}{ x\bindt t_x->t'}$ and $\hastype{\varnothing}{v}{t_x}$ then $\hastype{\varnothing}{\delta(c,v)}{t'[v/x]}$ (PrimitivesDeltaTyping.hs) (and similarly for the polymorphic Eql). The latter one, our ${\tt lem\_deltaT\_typ}$ depends on ${\tt lem\_subst\_tv\_sub}$.
%    \end{lemma}

%    \begin{theorem}
%        Progress Theorem: If $\varnothing \vdash e : t$ then either $e$ is a value or there exists a term $e'$ such that $e \hookrightarrow$ e'. (MainTheorems.hs) No significant dependencies.
%    \end{theorem}

%    \begin{theorem}
%        Preservation Theorem: If $\varnothing \vdash e : t$ and $e \hookrightarrow e'$, then $\varnothing \vdash e' : t$. (MainTheorems.hs)  Our ${\tt thm\_preservation}$ depends on ${\tt lem\_sem\_det}$, ${\tt lem\_value\_stuck}$, ${\tt lem\_subst\_typ}$, ${\tt lem\_invert\_tabs}$, ${\tt lem\_invert\_tabst}$, ${\tt lem\_delta\_typ}$, ${\tt lem\_detaT\_typ}$, and ${\tt thm\_progress}$.
%    \end{theorem}

\begin{comment}
\section{Subtyping and Entailments}

In order to prove the substitution lemma (\Cref{lem:subst})
for the subtyping judgments, the case of \sBase requires
us to prove a corresponding lemma for entailment judgments.

\begin{lemma} (Entailment Substitution) \label{lem:entail-base}
    \begin{enumerate}
        \item If $\entails{\tcenv',\bind{x}{t_x},\tcenv}{p}$,
                 $\isWellFormedE{\tcenv',\bind{x}{t_x},\tcenv}$,
            and $\hastype{\tcenv}{v_x}{t_x}$,
            then $\entails{\subst{\tcenv'}{x}{v_x},\tcenv}{\subst{p}{x}{v_x}}$.
            %(SubstitutionLemmaEnt.hs) This one uses ${\tt lem\_denote\_sound\_typ}$ \\
        \item If $\entails{\tcenv',\bind{\al}{\skind},\tcenv}{p}$,
                 $\isWellFormedE{\tcenv',\bind{\al}{\skind},\tcenv}$,
            and $\hastype{\tcenv}{t_\al}{\skind}$,
            then $\entails{\subst{\tcenv'}{\al}{t_\al},\tcenv}{\subst{p}{\al}{t_\al}]}$.
            %(SubstitutionLemmaEntTV.hs) \\
    \end{enumerate}
\end{lemma}

The proof of the above lemma depends
on Denotational Soundness (\Cref{lem:denote-sound-first})
to prove the particular statement about denotations
in the antecedent of rule \entPred holds under substitution.
%
Specifically, we are given the statement
$\foralltheta{\theta}{\tcenv',\bind{x}{t_x},\tcenv}
    \Rightarrow \evalsTo{\theta(p)}{\ttrue}$
and we need to show the statement
$\foralltheta{\theta'}{\subst{\tcenv'}{x}{v_x},\tcenv}
    \Rightarrow \evalsTo{\theta'(\subst{p}{x}{v_x})}{\ttrue}$ holds.
The second statement is a special case of the first;
for any appropriate $\theta'$ and $v_x$, the closing substitution
$\theta \defeq (\theta', x\mapsto v_x)$ is appropriate to the first statement.
%
The proof hinges on Denotational Soundness,
described below, which gives us $v_x \in \denote{\theta'(t_x)}$
and on the commutativity of substitution
($v_x$ is a closed value and so has no variables appearing in it).

\end{comment}
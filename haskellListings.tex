\usepackage{listings}

% uncomment next line to restore colors
% \def\withcolor{}


\ifdefined\withcolor
  \definecolor{haskellstr}{rgb}{0.2, 0.2, 0.6}
  \definecolor{haskellred}{rgb}{1.0, 0.0, 0.0}
  \definecolor{gray_ulisses}{gray}{0.55}
  \definecolor{green_ulises}{rgb}{0.2,0.75,0}
  \definecolor{haskelltypes}{rgb}{0.71,0.33,0.14}
  \definecolor{logiccolor}{rgb}{0.0, 0.0, 1.0}
\else
  \definecolor{haskellstr}{rgb}{0.2, 0.2, 0.6}
  \definecolor{haskellred}{gray}{0.1}
  \definecolor{gray_ulisses}{gray}{0.55}
  \definecolor{green_ulisses}{gray}{0.1}
  \definecolor{haskelltypes}{gray}{0.1}
  \definecolor{logiccolor}{gray}{0.1}
\fi

\definecolor{haskellblue}{rgb}{0.0, 0.0, 1.0}
\definecolor{haskell_green}{rgb}{0.0, 0.5, 0.0}
\definecolor{blue_violet}{rgb}{0.54, 0.17, 0.89}
\definecolor{castanho_ulisses}{rgb}{0.43, 0.21, 0.1}
\definecolor{preto_ulisses}{rgb}{0.21,0.00,0.80}

\definecolor{subtleOpHighlight}{rgb}{0.4, 0.2, 0.0}

% RJ: I don't like the colors. Too confusing.
%
% \definecolor{lcolor}{rgb}{0.0, 0.0, 1.0}
% \definecolor{lappcolor}{rgb}{1.0, 0.0, 0.0}
% \definecolor{lappascolor}{rgb}{0.0, 1.0, 0.0}

\definecolor{lcolor}{gray}{0.0}
\definecolor{lappcolor}{gray}{0.0}
\definecolor{lappascolor}{gray}{0.0}

\def\codesize{\normalsize}
% \def\codesize{\footnotesize}
\def\incodesize{\normalsize}


% \newcommand\showfocus[1]{\color{lappcolor}{#1}}
% \newcommand\showfocus[1]{\underbar{#1}}
\newcommand\showfocus[1]{\color{purple}{\textbf{#1}}}
\newcommand\showlogic[1]{\color{logiccolor}{#1}}

\lstdefinelanguage{HaskellUlisses} {
  aboveskip=\smallskipamount,
  belowskip=\smallskipamount,
  basicstyle=\ttfamily\codesize,
  moredelim=[is][\showfocus]{\#}{\#},
  moredelim=[is][\showlogic]{!}{!},
  sensitive=true,
  morecomment=[l][\color{gray_ulisses}\ttfamily\itshape\codesize]{--},
  % morecomment=[l][\color{green}]{--},
  % morecomment=[s][\color{gray_ulisses}\ttfamily\itshape\codesize]{\{-}{-\}},
  %morecomment=[l][\ttfamily\itshape\codesize]{--},
  %morecomment=[s][\ttfamily\itshape\codesize]{\{-}{-\}},
  morestring=[b]",
  %% escapeinside={(*}{*)},
  stringstyle=\color{haskellstr},
  showstringspaces=false,
  numberstyle=\codesize,
  numberblanklines=true,
  showspaces=false,
  breaklines=true,
  showtabs=false,
  %% whitespace hackery
  %%lineskip=-2pt,
  % aboveskip=0pt,
  % belowskip=0pt,
  literate={
           {<!}{{{\color{lcolor}<!}}}2
%           {==!}{{{\color{lcolor}==!}}}3
           {`}{{{$^{\backprime}{}$}}}1
           % {QED}{{{\color{lcolor}QED}}}3
           % {***}{{{\color{lcolor}***}}}3
           {?}{{{\color{lcolor}?}}}1
           {<=}{{$\leq\;\;$}}1
           {/=}{{$\neq$}}1
           {bot}{{$\bot$}}1
           {top}{{$\top$}}1
           {theta}{{$\theta$}}1
           {gf}{{{\color{lappascolor}f}}}1
           {rmap}{{{\color{lappcolor}map}}}3
           {gmap}{{{\color{lappascolor}map}}}3
           {r.}{{{\color{lappcolor}.}}}1
           {g.}{{{\color{lappascolor}.}}}1
           {r++}{{{\showfocus{++}}}}2
           {g++}{{{\color{lappascolor}++}}}2
           {>>}{{{\color{haskellblue}>>}}}2
           {>>=}{{{\color{haskellblue}>>=}}}3
           {</>}{{{\color{haskellblue}</>}}}3
           {<*>}{{{\color{haskellblue}<*>}}}3
           {++}{{{\color{haskellblue}++}}}3
           %{g>>=}{{{\color{lappascolor}>>=}}}3
           {gfib}{{{\color{lappascolor}fib}}}3
           {rfib}{{{\color{lappcolor}fib}}}3
           {r++}{{{\color{lappcolor}++}}}2
           % {>>=}{$\ebind$}2
           % {env}{{$\Gamma$}}1
           {|-}{{$\vdash\;$}}1
          % {>=}{{$\geq$}}1
          % {<}{{$<$}}1
          % {>}{{$>$}}1
           {<=!}{{{\color{lcolor}<=!}}}3
          % {\\}{{$\lambda$}}1
           {!=}{{$\neq$}}1
           % {forall}{{$\forall$}}1
           % {->}{{$\rightarrow$}}2
           {~>}{{$\imparrow$}}2
           {<-}{{$\leftarrow$}}2
           {->}{{$\rightarrow\;\;$}}2                    % added by Michael
           % {->}{{$\rightarrow\;\;$}}2                    % added by Michael
           {:=}{{$\defeq$}}2                          % added by Michael
           {Gamma}{{$\Gamma$}}1                        % added by Michael
           {dollar}{{$\texttt{\$}$}}1
% Testing messing around with these
%----------------------------------------
           %% {++}{{\color{subtleOpHighlight}{++}}}2
           %% {=.}{{\color{subtleOpHighlight}{=.}}}2
           %% {::}{{\color{subtleOpHighlight}{::}}}2
%           {=}{{\color{subtleOpHighlight}{=}}}1
%----------------------------------------
           {Set_mem}{{$\in$}}1
           {Set_cup}{{$\cup$}}1
           {Set_cap}{{$\cap$}}1
           {Set_emp}{{$\emptyset$}}1
           {Set_sub}{{$\subseteq$}}1
           {<=>}{{$\Leftrightarrow$}}3
           {=>}{{$\Rightarrow$}}2
           {1->}{{$\rightarrow$}}1
           {1=>}{{$\Rightarrow$}}1
           {||-}{{$\vdash$}}1
           {|->}{{$\mapsto$}}2
           {<:}{{$\preceq$}}1
           {Inarritu}{Inarritu}8},
%           {Inarritu}{I$\tilde{\text{n}}\acute{\text{a}}$rritu}8,
  emph=
  {[1]
    succ,incr,two,incrMany,three,id,new,get,set,return,grant,revoke,main,canRead,safeRead,
    test1,test2,
    gnt,rev,next,foo,bar,baz,pure,client,done,clynt,fin,
    FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
    asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
    cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
    dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
    error,even,exponent,fail,mapMaybe,filter,flip,floatDigits,floatRadix,floatRange,floor,
    foldl,foldl1,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
    fromRational,fst,gcd,put,tick,tock,tocker,ticker,getChar,getContents,getLine,head,inRange,index,init,intToDigit,
    interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
    isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
    last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,mapM,mapM_,max,
    maxBound,posMax,negMax,maximum,maybe,min,minBound,minimum,mod,negate,notElem,null,numerator,odd,
    or,ord,pi,pred,primExitWith,print,product,putChar,putStr,putStrLn,quot,
    quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
    readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
    reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
    showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
    sinh,snd,span,splitAt,sqrt,subtract,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
    toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
    unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3,listArray,doParse,empty,for,initTo,
        assert,compose,checkGE,maxEvens,empty,create,get,set,initialize,idVec,fastFib,fibMemo,
        ex1,ex2,ex3,inc,dec,isPos,positives,find,flatten, expand,exAll,
        ind,evenLen,lenAppend,exDistOr,allDistAnd,len,size,union,singleton,initUpto,trim,
        insertSort,decsort,qsort,reverse,append,upperCase, ifM, whileM, get, decrM, diff,
        project, select, sel, elts, keys, dkeys, dfun, addKey, pTrue, emptyRD, rFalse,
                dom, rng, isI, isD, isS, movie1, movie2,  toI, toS, toD, good_titles, runState, ret,
                update, getCtr, setCtr, ctr, rdCtr, wrCtr, ifTest, whileTest, posCtr, zeroCtr, decr, decCtr,
                pread , pwrite , plookup , pcontents, pcreateF , pcreateFP, pcreateD, active, caps, pset, eqP,
                write, contents, alloc, derivP, copyP, createDir, store, copyRec, copySpec,
                preservation, progress,subFV, safety, soundness, impossible, lemValStep, isVal,
                forM_, when, flookup, fread, createDir, pcreateFile, isFile, copyFrame, ?
  },
  emphstyle={[1]\color{haskellblue}},
  emph=
  {[2]Show,Eq,Iso,VerifiedOrd,Ord,Num,UpClosed,Comp,Wit,Witness,Inductive,match, end, Definition, Meet,Flip,TRUE,
      Peano,Nat,Prime, ArrayN,Pos,SInt,Neg,IntGE,Plus,List,PAnd, POr, POrL, POrR,
        Bool,Char,Double,Either,Float,IO,Integer,Int,Maybe,Up,Mono,Identity,
        Ordering,Rational,Ratio,ReadS,ShowS,File,Token,ST,String,Str,Word8,
        InPacket,Tree,Vec,NullTerm,IncrList,DecrList,
        UniqList,BST,MinHeap,MaxHeap,World,RIO,IO,HIO,Post,Pre, OptEq,
        Privilege, Chain, ChainTy, Range, Dict, RD, Dom, Set, P, Univ, Schema, MovieSchema, RT,
        TDom, TRange, MoviesTable, RTSubEqFlds, RTEqFlds, Disjoint, Union, Ret, Seq, Trans, Map,
        Pure, Then, Else, Exit, Inv, OneState, Priv, Path, FH, Stable,
      Monoid, VerifiedMonoid, VerifiedComMonoid, Plus_2_2_eq_4, Plus_2_2, Nat_up, Int_up,
      AppendNilId, AppendAssoc,MapFusion,
      Plus_comm, Par, Term,HasTyPr,HasTyEv,IsSubTyPr,IsSubTyEv,StepPr,StepEv, StepsPr,StepsEv,Env,Prim,Expr,Proposition,DataProp,VName,ProofOf,ProofOfN,Type,Names,Kind,
      HasTy,WfType,IsSubTy,Step,Steps,EvalsTo,Subtype,
      Formula, Assignment, Body, Accel, Real, Accel', RVar, VerifiedCommutativeMonoid, CommutativeMonoid
  },
  emphstyle={[2]\color{blue_violet}},
  emph=
  {[3]
    case,class,newtype,data,deriving,do,else,if,unpack,import,in,infixl,infixr,instance,let,
    module,of,primitive,then,refinement,type,where,forall,bound,expr,vname, env, prim, bool,
    % otherwise,
    measure,reflect,predicate, instance, class,
    exists, Qed, Theorem, Proof, option, Lemma
  },
  emphstyle={[3]\color{castanho_ulisses}\textbf},
  emph=
  {[4]
    quot,rem,div,mod,elem,notElem,seq
  },
  emphstyle={[4]\color{preto_ulisses}},
  emph=
  {[5]
    EQ,GT,LT,Left,Right,SBase,TPrim,TSub,TAbs,TAbsEx,TAbsCQ,
    TRefn,TInt,EApp,EPrim,EEq,EVar,PInt,Empty,Cons,EVar,ELam,EApp,TFunc,
    Refl,AddStep, Add
    %, False, True, Just, Nothing
  },
  emphstyle={[5]\color{haskell_green}},
  emph=
  {[6]
      axiomatize, measure, inline
  },
  emphstyle={[6]\color{lcolor}\ttfamily\itshape},
  emph=
  {[6]
      hasTyEvPr,isSubTyEvPr
  }
}

%%%ORIG
%%%\lstnewenvironment{code}
%%%{\textbf{Haskell Code} \hspace{1cm} \hrulefill \lstset{language=HaskellUlisses}}
%%%{\hrule\smallskip}

%V1
%\lstnewenvironment{code}
%{\smallskip \lstset{language=HaskellUlisses}}
%{\smallskip}

\lstnewenvironment{code}
{\lstset{language=HaskellUlisses}}
{}

\lstnewenvironment{mcode}
{\lstset{language=HaskellUlisses,columns=fullflexible,keepspaces,mathescape}}
{}

\lstnewenvironment{mcodef}
{\lstset{language=HaskellUlisses,columns=fullflexible,keepspaces,mathescape,frame=single}}
{}

\lstMakeShortInline[language=HaskellUlisses,mathescape,keepspaces,mathescape,basicstyle=\ttfamily\codesize,breakatwhitespace]@

\lstdefinelanguage{Pseudo} {
  basicstyle=\ttfamily\codesize,
  sensitive=true,
  mathescape=true,
  morecomment=[l][\color{gray_ulisses}\ttfamily\codesize]{--},
  morecomment=[s][\color{gray_ulisses}\ttfamily\codesize]{\{-}{-\}},
  morestring=[b]",
  showstringspaces=false,
  numberstyle=\codesize,
  numberblanklines=true,
  showspaces=false,
  breaklines=true,
  showtabs=false
}

\lstdefinelanguage{java} {
    keywordstyle=[1],
    keywordstyle=[2]\color{ForestGreen},
    keywordstyle=[3]\color{Bittersweet},
    keywordstyle=[4]\color{RoyalPurple},
    morekeywords={region,private,synchronized}
}


%%% PSEUDOCODE LISTING Python Style

\ifdefined\withcolor
        \definecolor{typecol}{rgb}{0.0,0.5,0.0}
        \definecolor{funcol}{rgb}{0.0,0.1,0.9}
        % BROWN \definecolor{typecol}{rgb}{0.71,0.33,0.14}
        % PURPLE \definecolor{funcol}{rgb}{0.8,0.0,0.6}
\else
        \definecolor{typecol}{gray}{0.0}
        \definecolor{funcol}{gray}{0.0}
\fi

\lstdefinelanguage{pseudo2}{
  language=Python,
  basicstyle=\ttfamily\normalsize,
  mathescape=true,
  morekeywords={type,def,do,let,unpack},
  emph={[1] \Expr,\Pred, HP, FP, Int},
  emphstyle={[1]\itshape\color{typecol}},
  emph={[2] \pbe,normalize},
  emphstyle={[2]\itshape\color{funcol}},
  % numbers=left,
  emph={[3] repeat,until},
  emphstyle={[3]\textbf}
}

\lstnewenvironment{code2}{\lstset{language=pseudo2}}{}

\lstnewenvironment{fscode}
{\lstset{language=HaskellUlisses,basicstyle=\ttfamily\small,mathescape=true}}
{}

%% \lstnewenvironment{code}
%% {\lstset{language=HaskellUlisses,mathescape=true}}
%% {}

\lstnewenvironment{codebox}
{\lstset{language=HaskellUlisses,frame=tlbr,basicstyle=\ttfamily\codesize,mathescape=true}}
{}

\def \ha {\lstinline[language=HaskellUlisses,basicstyle=\ttfamily\incodesize,mathescape=true]}
